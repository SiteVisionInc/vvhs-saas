			  
					  
======================================
File: audit.py
Path: ./api/app/services
--------------------------------------
"""
Audit logging service for tracking user actions.
"""
from typing import Optional
from sqlalchemy.orm import Session
from datetime import datetime

from models.audit import AuditLog


def log_action(
    db: Session,
    user_id: int,
    tenant_id: int,
    action: str,
    resource_type: str,
    resource_id: Optional[int] = None,
    description: Optional[str] = None,
    old_values: Optional[dict] = None,
    new_values: Optional[dict] = None,
    ip_address: Optional[str] = None,
    user_agent: Optional[str] = None,
    status: str = "success"
):
    """
    Create an audit log entry.
    
    Args:
        db: Database session
        user_id: ID of user performing action
        tenant_id: Tenant ID
        action: Action name (e.g., "volunteer.created")
        resource_type: Type of resource (e.g., "volunteer")
        resource_id: ID of affected resource
        description: Human-readable description
        old_values: Previous state (for updates)
        new_values: New state
        ip_address: Client IP address
        user_agent: Client user agent
        status: Action status (success, failure, error)
    """
    audit_log = AuditLog(
        user_id=user_id,
        tenant_id=tenant_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        description=description,
        old_values=old_values,
        new_values=new_values,
        ip_address=ip_address,
        user_agent=user_agent,
        status=status,
        created_at=datetime.utcnow()
    )
    
    db.add(audit_log)
    db.commit()
    
    return audit_log
======================================

======================================
File: train.py
Path: ./api/app/services
--------------------------------------
# api/app/services/train.py
"""
TRAIN API integration service.
Currently simulated - will be replaced with real TRAIN API in Phase 2.
"""
from typing import List, Dict, Any
from datetime import datetime, date, timedelta
import random

from config import get_settings

settings = get_settings()


class TRAINService:
    """
    Service for integrating with TRAIN Learning Network API.
    This is a SIMULATED implementation for Phase 1.
    """
    
    def __init__(self):
        self.base_url = settings.TRAIN_API_URL
        self.api_key = settings.TRAIN_API_KEY
    
    async def sync_volunteer_training(self, volunteer_email: str) -> List[Dict[str, Any]]:
        """
        Sync training records for a volunteer from TRAIN.
        
        SIMULATED: Returns mock data for demonstration.
        
        Args:
            volunteer_email: Volunteer's email (used for TRAIN lookup)
            
        Returns:
            List of training record dictionaries
        """
        # Simulate API delay
        import asyncio
        await asyncio.sleep(0.5)
        
        # Return simulated training data
        return [
            {
                "train_course_id": "TRAIN-ICS100",
                "train_completion_id": f"COMP-{random.randint(10000, 99999)}",
                "course_name": "ICS 100: Introduction to Incident Command System",
                "course_code": "ICS-100",
                "course_category": "Emergency Management",
                "course_provider": "FEMA",
                "completion_date": date.today() - timedelta(days=random.randint(30, 365)),
                "expiration_date": date.today() + timedelta(days=random.randint(365, 1460)),
                "score": round(random.uniform(85, 100), 2),
                "certificate_url": f"https://train.org/certificates/COMP-{random.randint(10000, 99999)}.pdf"
            },
            {
                "train_course_id": "TRAIN-NIMS700",
                "train_completion_id": f"COMP-{random.randint(10000, 99999)}",
                "course_name": "IS-700: National Incident Management System",
                "course_code": "IS-700",
                "course_category": "Emergency Management",
                "course_provider": "FEMA",
                "completion_date": date.today() - timedelta(days=random.randint(30, 365)),
                "expiration_date": None,  # No expiration
                "score": round(random.uniform(85, 100), 2),
                "certificate_url": f"https://train.org/certificates/COMP-{random.randint(10000, 99999)}.pdf"
            },
            {
                "train_course_id": "TRAIN-CPR",
                "train_completion_id": f"COMP-{random.randint(10000, 99999)}",
                "course_name": "CPR/AED for Healthcare Providers",
                "course_code": "CPR-HEALTH",
                "course_category": "Medical",
                "course_provider": "American Heart Association",
                "completion_date": date.today() - timedelta(days=random.randint(30, 365)),
                "expiration_date": date.today() + timedelta(days=random.randint(365, 730)),
                "score": round(random.uniform(85, 100), 2),
                "certificate_url": f"https://train.org/certificates/COMP-{random.randint(10000, 99999)}.pdf"
            }
        ]
    
    async def get_course_details(self, course_id: str) -> Dict[str, Any]:
        """
        Get details about a TRAIN course.
        
        SIMULATED: Returns mock course data.
        
        Args:
            course_id: TRAIN course identifier
            
        Returns:
            Course details dictionary
        """
        import asyncio
        await asyncio.sleep(0.2)
        
        # Simulated course catalog
        courses = {
            "TRAIN-ICS100": {
                "course_id": "TRAIN-ICS100",
                "name": "ICS 100: Introduction to Incident Command System",
                "description": "This course introduces the Incident Command System (ICS) and provides the foundation for higher level ICS training.",
                "duration_hours": 3,
                "provider": "FEMA",
                "category": "Emergency Management",
                "is_required": True,
                "validity_period_days": 1460  # 4 years
            },
            "TRAIN-CPR": {
                "course_id": "TRAIN-CPR",
                "name": "CPR/AED for Healthcare Providers",
                "description": "Learn to recognize cardiac arrest, provide high-quality chest compressions, deliver appropriate ventilations and use an AED.",
                "duration_hours": 4,
                "provider": "American Heart Association",
                "category": "Medical",
                "is_required": True,
                "validity_period_days": 730  # 2 years
            }
        }
        
        return courses.get(course_id, {
            "course_id": course_id,
            "name": "Unknown Course",
            "description": "Course details not found",
            "duration_hours": 0,
            "provider": "Unknown"
        })
    
    async def check_training_requirements(
        self,
        volunteer_trainings: List[Dict[str, Any]],
        required_courses: List[str]
    ) -> Dict[str, bool]:
        """
        Check if volunteer meets training requirements.
        
        Args:
            volunteer_trainings: List of volunteer's completed trainings
            required_courses: List of required TRAIN course IDs
            
        Returns:
            Dictionary mapping course IDs to completion status
        """
        completed_courses = {
            t["train_course_id"] 
            for t in volunteer_trainings 
            if t.get("train_course_id")
        }
        
        return {
            course_id: course_id in completed_courses
            for course_id in required_courses
        }


# Singleton instance
train_service = TRAINService()======================================

======================================
File: s3_storage.py
Path: ./api/app/services
--------------------------------------
# api/app/services/s3_storage.py
"""
S3 document storage service with presigned URLs.
"""
import boto3
import hashlib
import mimetypes
from typing import Optional, Tuple
from botocore.exceptions import ClientError
from config import get_settings

settings = get_settings()


class S3StorageService:
    """
    Service for secure document storage in AWS S3.
    """
    
    def __init__(self):
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_REGION
        )
        self.bucket_name = settings.S3_BUCKET_NAME
    
    def generate_upload_url(
        self,
        file_name: str,
        file_type: str,
        tenant_id: int,
        document_type: str,
        expires_in: int = 3600
    ) -> Tuple[str, str]:
        """
        Generate presigned URL for direct upload to S3.
        
        Returns:
            Tuple of (presigned_url, s3_key)
        """
        # Generate unique S3 key
        s3_key = self._generate_s3_key(tenant_id, document_type, file_name)
        
        # Content type
        content_type = file_type or mimetypes.guess_type(file_name)[0] or 'application/octet-stream'
        
        try:
            presigned_url = self.s3_client.generate_presigned_url(
                'put_object',
                Params={
                    'Bucket': self.bucket_name,
                    'Key': s3_key,
                    'ContentType': content_type,
                    'ServerSideEncryption': 'AES256',  # Encrypt at rest
                    'Metadata': {
                        'tenant-id': str(tenant_id),
                        'document-type': document_type
                    }
                },
                ExpiresIn=expires_in,
                HttpMethod='PUT'
            )
            
            return presigned_url, s3_key
            
        except ClientError as e:
            raise Exception(f"Failed to generate presigned URL: {str(e)}")
    
    def generate_download_url(
        self,
        s3_key: str,
        expires_in: int = 3600
    ) -> str:
        """
        Generate presigned URL for downloading a document.
        """
        try:
            presigned_url = self.s3_client.generate_presigned_url(
                'get_object',
                Params={
                    'Bucket': self.bucket_name,
                    'Key': s3_key
                },
                ExpiresIn=expires_in
            )
            return presigned_url
            
        except ClientError as e:
            raise Exception(f"Failed to generate download URL: {str(e)}")
    
    def delete_document(self, s3_key: str) -> bool:
        """
        Delete a document from S3.
        """
        try:
            self.s3_client.delete_object(
                Bucket=self.bucket_name,
                Key=s3_key
            )
            return True
        except ClientError as e:
            print(f"Error deleting document: {e}")
            return False
    
    def get_file_hash(self, s3_key: str) -> Optional[str]:
        """
        Calculate SHA-256 hash of file in S3.
        """
        try:
            response = self.s3_client.get_object(
                Bucket=self.bucket_name,
                Key=s3_key
            )
            
            hash_sha256 = hashlib.sha256()
            for chunk in response['Body'].iter_chunks(chunk_size=8192):
                hash_sha256.update(chunk)
            
            return hash_sha256.hexdigest()
            
        except ClientError as e:
            print(f"Error calculating hash: {e}")
            return None
    
    def _generate_s3_key(self, tenant_id: int, document_type: str, file_name: str) -> str:
        """
        Generate organized S3 key path.
        Format: documents/{tenant_id}/{document_type}/{timestamp}_{filename}
        """
        import uuid
        from datetime import datetime
        
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        unique_id = str(uuid.uuid4())[:8]
        safe_filename = file_name.replace(' ', '_').replace('/', '_')
        
        return f"documents/{tenant_id}/{document_type}/{timestamp}_{unique_id}_{safe_filename}"


# Singleton instance
try:
    s3_storage = S3StorageService()
except Exception as e:
    print(f"[WARN] S3StorageService initialization failed: {e}")
    s3_storage = None
======================================

======================================
File: database.py
Path: ./api/app
--------------------------------------
"""
Database configuration and session management.
Uses SQLAlchemy 2.0 async patterns.
"""
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config import get_settings

settings = get_settings()

# Create database engine
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=settings.DEBUG
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()


def get_db():
    """Dependency for getting database sessions."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
======================================

======================================
File: test_time_entries.py
Path: ./api/app
--------------------------------------
# api/app/test_time_entries.py - Quick diagnostic script
"""
Run this to check if time entries exist in the database.
Usage: docker exec -it vvhs-api python test_time_entries.py
"""
from database import SessionLocal
from models.time_tracking import TimeEntry
from models.volunteer import Volunteer

db = SessionLocal()

print("\n=== TIME ENTRIES DIAGNOSTIC ===\n")

# Check total time entries
total = db.query(TimeEntry).count()
print(f"Total time entries in database: {total}")

# Check by status
pending = db.query(TimeEntry).filter(TimeEntry.status == 'pending').count()
approved = db.query(TimeEntry).filter(TimeEntry.status == 'approved').count()

print(f"  - Pending: {pending}")
print(f"  - Approved: {approved}")

# List all entries with details
print("\nAll Time Entries:")
entries = db.query(TimeEntry).all()
for entry in entries:
    volunteer = db.query(Volunteer).filter(Volunteer.id == entry.volunteer_id).first()
    volunteer_name = f"{volunteer.first_name} {volunteer.last_name}" if volunteer else "Unknown"
    print(f"  â€¢ ID {entry.id}: {volunteer_name} - {entry.hours_decimal} hrs - Status: {entry.status}")

print("\n=== END DIAGNOSTIC ===\n")

db.close()
======================================

======================================
File: event_assignment.py
Path: ./api/app/models
--------------------------------------
"""
Event Assignment model for volunteer-event relationships.
"""
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, DECIMAL, Text, UniqueConstraint
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base


class EventAssignment(Base):
    """
    Model for tracking volunteer assignments to events.
    """
    __tablename__ = "event_assignments"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id", ondelete="CASCADE"), nullable=False)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False)
    shift_id = Column(Integer, ForeignKey("shifts.id"), nullable=True)
    
    # Status - using string instead of enum for flexibility
    status = Column(String(20), nullable=False, default='pending')
    
    # Hours tracking
    hours_completed = Column(DECIMAL(5, 2))
    hours_served = Column(DECIMAL(5, 2))
    
    # Check-in/Check-out
    check_in_time = Column(DateTime)
    check_out_time = Column(DateTime)
    
    # Notes
    notes = Column(Text)
    coordinator_notes = Column(Text)
    volunteer_notes = Column(Text)
    
    # Timestamps
    assigned_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    assigned_by = Column(Integer, ForeignKey("users.id"))
    confirmed_at = Column(DateTime)
    completed_at = Column(DateTime)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    event = relationship("Event", back_populates="assignments")
    volunteer = relationship("Volunteer", back_populates="event_assignments")
    shift = relationship("Shift", back_populates="assignments", lazy="joined")
    
    __table_args__ = (
        UniqueConstraint('event_id', 'volunteer_id', 'shift_id', name='_event_volunteer_shift_uc'),
    )
    
    def __repr__(self):
        return f"<EventAssignment(id={self.id}, event={self.event_id}, volunteer={self.volunteer_id}, status='{self.status}')>"======================================

======================================
File: user.py
Path: ./api/app/models
--------------------------------------
"""
User model for staff and administrators.
Implements role-based access control (RBAC).
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from database import Base


class UserRole(str, enum.Enum):
    """User role enumeration matching the requirements."""
    SYSTEM_ADMIN = "system_admin"           # State-level users, full system access
    ORG_ADMIN = "org_admin"                 # Local-level users (Unit Coordinators)
    COORDINATOR = "coordinator"              # Unit Coordinators with management access
    SUB_UNIT_STAFF = "sub_unit_staff"       # Local-level users with limited permissions
    VOLUNTEER = "volunteer"                  # Volunteer users (for portal access)


class UserStatus(str, enum.Enum):
    """User account status."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"
    PENDING = "pending"


class User(Base):
    """
    User model for staff members and administrators.
    Separate from Volunteer model as staff have different access patterns.
    """
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # Authentication
    username = Column(String(100), nullable=False, unique=True, index=True)
    email = Column(String(255), nullable=False, unique=True, index=True)
    hashed_password = Column(String(255), nullable=False)
    
    # Profile
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    phone = Column(String(20))
    
    # Role and permissions
    role = Column(
        SQLEnum(UserRole, values_callable=lambda obj: [e.value for e in obj]),
        nullable=False,
        default=UserRole.SUB_UNIT_STAFF
    )
    status = Column(
        SQLEnum(UserStatus, values_callable=lambda obj: [e.value for e in obj]),
        nullable=False,
        default=UserStatus.PENDING
    )
    
    # Sub-unit staff permissions (as radio buttons in requirements)
    can_view_data = Column(Boolean, default=True)
    can_edit_data = Column(Boolean, default=False)
    can_send_password_reminder = Column(Boolean, default=False)
    can_initiate_transfers = Column(Boolean, default=False)
    can_approve_transfers = Column(Boolean, default=False)
    can_view_alerts = Column(Boolean, default=True)
    can_edit_alerts = Column(Boolean, default=False)
    can_export_data = Column(Boolean, default=False)
    
    # Multi-factor authentication
    mfa_enabled = Column(Boolean, default=False)
    mfa_secret = Column(String(255))
    
    # Timestamps
    last_login = Column(DateTime)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    tenant = relationship("Tenant", back_populates="users")
    audit_logs = relationship("AuditLog", back_populates="user")
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}', role='{self.role}')>"
    
    @property
    def full_name(self):
        """Get user's full name."""
        return f"{self.first_name} {self.last_name}"
        
    @property
    def is_active(self):
        return self.status == "active"

    @property
    def is_superuser(self):
        return self.role == "system_admin"
======================================

======================================
File: document.py
Path: ./api/app/models
--------------------------------------
# api/app/models/document.py
"""
Document management models for policy documents, signatures, and volunteer documents.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Date, BigInteger
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from datetime import datetime, date, timedelta
from database import Base


class PolicyDocument(Base):
    """
    Organizational policy documents that require acknowledgment.
    """
    __tablename__ = "policy_documents"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    
    # Document info
    title = Column(String(255), nullable=False)
    description = Column(Text)
    document_type = Column(String(100), nullable=False)
    version = Column(String(50), nullable=False)
    
    # File storage
    file_url = Column(String(500), nullable=False)
    file_size_bytes = Column(Integer)
    file_hash = Column(String(255))
    
    # Status
    is_active = Column(Boolean, default=True)
    requires_signature = Column(Boolean, default=False)
    
    # Metadata
    created_by = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    effective_date = Column(Date)
    expiration_date = Column(Date)
    
    # Version control
    supersedes_document_id = Column(Integer, ForeignKey("policy_documents.id"))
    
    # Relationships
    signatures = relationship("ElectronicSignature", back_populates="policy_document")
    
    def __repr__(self):
        return f"<PolicyDocument(id={self.id}, title='{self.title}', version='{self.version}')>"
    
    @property
    def is_expired(self) -> bool:
        if not self.expiration_date:
            return False
        return self.expiration_date < date.today()


class ElectronicSignature(Base):
    """
    Electronic signatures for policy acknowledgment and document signing.
    Implements non-repudiation requirements.
    """
    __tablename__ = "electronic_signatures"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Who signed
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"))
    user_id = Column(Integer, ForeignKey("users.id"))
    
    # What was signed
    policy_document_id = Column(Integer, ForeignKey("policy_documents.id"))
    custom_document_id = Column(Integer, ForeignKey("volunteer_documents.id"))
    
    # Signature data
    signature_data = Column(Text)  # Base64 encoded
    signature_method = Column(String(50), nullable=False)
    
    # Legal requirements
    ip_address = Column(String(45), nullable=False)
    user_agent = Column(Text)
    geolocation = Column(JSONB)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Consent
    consent_text = Column(Text, nullable=False)
    acknowledged_terms = Column(Boolean, default=True)
    
    # Verification
    verified = Column(Boolean, default=False)
    verification_method = Column(String(100))
    verified_at = Column(DateTime)
    verified_by = Column(Integer, ForeignKey("users.id"))
    
    # Relationships
    policy_document = relationship("PolicyDocument", back_populates="signatures")
    volunteer = relationship("Volunteer")
    
    def __repr__(self):
        signer = f"volunteer_{self.volunteer_id}" if self.volunteer_id else f"user_{self.user_id}"
        return f"<ElectronicSignature(id={self.id}, signer={signer}, timestamp={self.timestamp})>"


class VolunteerDocument(Base):
    """
    Documents uploaded by or for volunteers (IDs, licenses, certifications, etc.).
    """
    __tablename__ = "volunteer_documents"
    
    id = Column(Integer, primary_key=True, index=True)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    
    # Classification
    document_type = Column(String(100), nullable=False)
    document_category = Column(String(100))
    title = Column(String(255), nullable=False)
    description = Column(Text)
    
    # File storage
    file_url = Column(String(500), nullable=False)
    file_name = Column(String(255))
    file_size_bytes = Column(Integer)
    file_type = Column(String(50))
    file_hash = Column(String(255))
    
    # Expiration
    issue_date = Column(Date)
    expiration_date = Column(Date)
    expires = Column(Boolean, default=False)
    
    # Verification
    verification_status = Column(String(50), default='pending')
    verified_by = Column(Integer, ForeignKey("users.id"))
    verified_at = Column(DateTime)
    rejection_reason = Column(Text)
    
    # Access control
    visibility = Column(String(50), default='private')
    
    # Notifications
    expiration_notified = Column(Boolean, default=False)
    last_notification_date = Column(Date)
    
    # Metadata
    uploaded_by = Column(Integer, ForeignKey("users.id"))
    uploaded_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Audit
    download_count = Column(Integer, default=0)
    last_accessed_at = Column(DateTime)
    
    # Relationships
    volunteer = relationship("Volunteer")
    signatures = relationship("ElectronicSignature", foreign_keys="[ElectronicSignature.custom_document_id]")
    
    def __repr__(self):
        return f"<VolunteerDocument(id={self.id}, type='{self.document_type}', volunteer={self.volunteer_id})>"
    
    @property
    def is_expired(self) -> bool:
        if not self.expires or not self.expiration_date:
            return False
        return self.expiration_date < date.today()
    
    @property
    def days_until_expiration(self) -> int:
        if not self.expires or not self.expiration_date:
            return 999999
        delta = self.expiration_date - date.today()
        return delta.days


class DocumentAccessLog(Base):
    """
    Audit trail for document access (required for HIPAA compliance).
    """
    __tablename__ = "document_access_log"
    
    id = Column(BigInteger, primary_key=True, index=True)
    
    # What
    document_id = Column(Integer)
    document_type = Column(String(100))
    
    # Who
    user_id = Column(Integer, ForeignKey("users.id"))
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"))
    
    # How
    action = Column(String(50), nullable=False)
    ip_address = Column(String(45))
    user_agent = Column(Text)
    
    # When
    accessed_at = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Context
    meta_data = Column("metadata", JSONB)
    
    def __repr__(self):
        return f"<DocumentAccessLog(id={self.id}, action='{self.action}', at={self.accessed_at})>"
======================================

======================================
File: audit.py
Path: ./api/app/models
--------------------------------------
"""
Audit logging model for compliance and security.
Tracks all significant user actions in the system.
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base


class AuditLog(Base):
    """
    Audit log for tracking user actions.
    Required for compliance (HIPAA, security standards).
    """
    __tablename__ = "audit_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # User and Tenant
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # Action Details
    action = Column(String(100), nullable=False, index=True)  # e.g., "user.created", "volunteer.updated"
    resource_type = Column(String(50), nullable=False)  # e.g., "volunteer", "event"
    resource_id = Column(Integer)
    
    # Request Information
    ip_address = Column(String(45))
    user_agent = Column(String(255))
    endpoint = Column(String(255))
    http_method = Column(String(10))
    
    # Change Details
    old_values = Column(JSON)  # Previous state (for updates)
    new_values = Column(JSON)  # New state
    
    # Additional Context
    description = Column(Text)
    status = Column(String(20))  # success, failure, error
    
    # Timestamp
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    
    # Relationships
    user = relationship("User", back_populates="audit_logs")
    
    def __repr__(self):
        return f"<AuditLog(id={self.id}, action='{self.action}', user_id={self.user_id})>"
======================================

======================================
File: tenant.py
Path: ./api/app/models
--------------------------------------
"""
Tenant model for multi-tenant SaaS architecture.
Each tenant represents a health district or organization.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base


class Tenant(Base):
    """
    Tenant/Organization model.
    Represents a health district or MRC unit using the system.
    """
    __tablename__ = "tenants"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, unique=True, index=True)
    slug = Column(String(100), nullable=False, unique=True, index=True)
    contact_email = Column(String(255), nullable=False)
    contact_phone = Column(String(20))
    
    # Address information
    address_line1 = Column(String(255))
    address_line2 = Column(String(255))
    city = Column(String(100))
    state = Column(String(2), default="VA")
    zip_code = Column(String(10))
    
    # Status and settings
    is_active = Column(Boolean, default=True, nullable=False)
    settings = Column(Text)  # JSON field for tenant-specific settings
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    users = relationship("User", back_populates="tenant", cascade="all, delete-orphan")
    volunteers = relationship("Volunteer", back_populates="tenant", cascade="all, delete-orphan")
    events = relationship("Event", back_populates="tenant", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Tenant(id={self.id}, name='{self.name}', slug='{self.slug}')>"
======================================

======================================
File: training.py
Path: ./api/app/models
--------------------------------------
# api/app/models/training.py
"""
Training and certification models.
Integrates with TRAIN API for course completion tracking.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Date, DECIMAL
from sqlalchemy.orm import relationship
from datetime import datetime, date
from database import Base


class TrainingCourse(Base):
    """
    Training course catalog including TRAIN courses.
    """
    __tablename__ = "training_courses"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # TRAIN Integration
    train_course_id = Column(String(100), unique=True, index=True)
    
    # Course Information
    name = Column(String(255), nullable=False)
    description = Column(Text)
    course_code = Column(String(50))
    provider = Column(String(255))
    category = Column(String(100))
    
    # Requirements
    is_required = Column(Boolean, default=False)
    validity_period_days = Column(Integer)  # NULL = no expiration
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    training_records = relationship("VolunteerTraining", back_populates="course")
    
    def __repr__(self):
        return f"<TrainingCourse(id={self.id}, name='{self.name}')>"


class VolunteerTraining(Base):
    """
    Training completion record for volunteers.
    Synced from TRAIN API daily.
    """
    __tablename__ = "volunteer_training"
    
    id = Column(Integer, primary_key=True, index=True)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False, index=True)
    course_id = Column(Integer, ForeignKey("training_courses.id"), nullable=False)
    
    # Completion Details
    completion_date = Column(Date, nullable=False)
    expiration_date = Column(Date)
    score = Column(DECIMAL(5, 2))
    certificate_number = Column(String(100))
    certificate_url = Column(String(500))
    
    # TRAIN Sync
    train_completion_id = Column(String(100), unique=True)
    synced_from_train = Column(Boolean, default=False)
    last_sync_date = Column(DateTime)
    
    # Status
    status = Column(String(50), default='active')  # active, expired, revoked
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    volunteer = relationship("Volunteer", back_populates="training_records")
    course = relationship("TrainingCourse", back_populates="training_records")
    
    @property
    def is_expired(self) -> bool:
        """Check if training has expired."""
        if not self.expiration_date:
            return False
        return self.expiration_date < date.today()
    
    def __repr__(self):
        return f"<VolunteerTraining(id={self.id}, volunteer={self.volunteer_id}, course={self.course_id})>"


class Certification(Base):
    """
    Professional licenses and certifications.
    Separate from training courses (e.g., RN license, EMT certification).
    """
    __tablename__ = "certifications"
    
    id = Column(Integer, primary_key=True, index=True)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False, index=True)
    
    # Certification Details
    certification_type = Column(String(100), nullable=False)
    license_number = Column(String(100))
    issuing_authority = Column(String(255))
    
    # Dates
    issue_date = Column(Date)
    expiration_date = Column(Date)
    
    # Verification
    verification_status = Column(String(50), default='pending')
    verification_date = Column(Date)
    verification_method = Column(String(100))
    verified_by = Column(Integer, ForeignKey("users.id"))
    
    # Document
    document_url = Column(String(500))
    document_type = Column(String(50))
    
    # Notes
    notes = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    volunteer = relationship("Volunteer")
    
    @property
    def is_expired(self) -> bool:
        """Check if certification has expired."""
        if not self.expiration_date:
            return False
        return self.expiration_date < date.today()
    
    @property
    def days_until_expiration(self) -> int:
        """Get days until expiration."""
        if not self.expiration_date:
            return 999999
        delta = self.expiration_date - date.today()
        return delta.days
    
    def __repr__(self):
        return f"<Certification(id={self.id}, type='{self.certification_type}', volunteer={self.volunteer_id})>"


class TrainingRequirement(Base):
    """
    Training requirements for events or roles.
    Used to restrict scheduling based on training compliance.
    """
    __tablename__ = "training_requirements"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    
    # Requirement Details
    name = Column(String(255), nullable=False)
    description = Column(Text)
    
    # Linked Course
    course_id = Column(Integer, ForeignKey("training_courses.id"))
    
    # Applicability
    required_for_roles = Column(Text)  # JSON array
    required_for_event_types = Column(Text)  # JSON array
    
    # Grace Period
    grace_period_days = Column(Integer, default=0)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<TrainingRequirement(id={self.id}, name='{self.name}')>"======================================

======================================
File: __init__.py
Path: ./api/app/models
--------------------------------------
# api/app/models/__init__.py
"""
Models package initialization.
Imports all models for Alembic auto-generation.
"""
from models.tenant import Tenant
from models.user import User, UserRole, UserStatus
from models.volunteer import Volunteer, VolunteerStatus, AccountStatus, MRCLevel
from models.event import Event, Shift, EventAssignment, ActivityType, EventStatus, AssignmentStatus
from models.training import (
    TrainingCourse,
    VolunteerTraining,
    Certification,
    TrainingRequirement
)
from models.audit import AuditLog
from models.time_tracking import TimeEntry, EventQRCode, CheckinSession
from models.document import (
    PolicyDocument,
    ElectronicSignature,
    VolunteerDocument,
    DocumentAccessLog
)

__all__ = [
    "Tenant",
    "User",
    "UserRole",
    "UserStatus",
    "Volunteer",
    "VolunteerStatus",
    "AccountStatus",
    "MRCLevel",
    "Event",
    "Shift",
    "EventAssignment",
    "ActivityType",
    "EventStatus",
    "AssignmentStatus",
    "TrainingCourse",
    "VolunteerTraining",
    "Certification",
    "TrainingRequirement",
    "AuditLog",
    "TimeEntry",
    "EventQRCode",
    "CheckinSession",
    "PolicyDocument",
    "ElectronicSignature",
    "VolunteerDocument",
    "DocumentAccessLog",
]======================================

======================================
File: reporting.py
Path: ./api/app/models
--------------------------------------
# api/app/models/reporting.py
"""
Reporting models.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base


class SavedReport(Base):
    """Saved report configuration."""
    __tablename__ = "saved_reports"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # Report metadata
    name = Column(String(255), nullable=False)
    description = Column(Text)
    report_type = Column(String(100), nullable=False, index=True)
    
    # Configuration
    query_config = Column(JSONB, nullable=False)
    visualization_config = Column(JSONB)
    
    # Scheduling
    schedule_config = Column(JSONB)
    last_generated_at = Column(DateTime)
    next_scheduled_at = Column(DateTime)
    
    # Sharing
    is_public = Column(Boolean, default=False)
    shared_with_roles = Column(Text)
    shared_with_users = Column(Text)
    
    # Ownership
    created_by = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Status
    is_active = Column(Boolean, default=True)
    
    # Relationships
    executions = relationship("ReportExecution", back_populates="report", cascade="all, delete-orphan")


class ReportExecution(Base):
    """Report execution history."""
    __tablename__ = "report_executions"
    
    id = Column(Integer, primary_key=True, index=True)
    report_id = Column(Integer, ForeignKey("saved_reports.id"), nullable=False)
    
    # Execution details
    executed_by = Column(Integer, ForeignKey("users.id"))
    executed_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    execution_time_ms = Column(Integer)
    row_count = Column(Integer)
    
    # Output
    file_url = Column(String(500))
    file_format = Column(String(20))
    file_size_bytes = Column(Integer)
    
    # Status
    status = Column(String(50), default='pending')
    error_message = Column(Text)
    
    # Relationships
    report = relationship("SavedReport", back_populates="executions")


class ReportField(Base):
    """Report builder field definitions."""
    __tablename__ = "report_fields"
    
    id = Column(Integer, primary_key=True, index=True)
    entity_type = Column(String(100), nullable=False)
    field_name = Column(String(100), nullable=False)
    field_label = Column(String(255), nullable=False)
    field_type = Column(String(50), nullable=False)
    is_filterable = Column(Boolean, default=True)
    is_groupable = Column(Boolean, default=True)
    is_aggregatable = Column(Boolean, default=False)
    aggregation_functions = Column(Text)


class ReportWorkflow(Base):
    """Workflow automation rules."""
    __tablename__ = "report_workflows"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    
    # Workflow details
    name = Column(String(255), nullable=False)
    description = Column(Text)
    
    # Trigger
    trigger_report_id = Column(Integer, ForeignKey("saved_reports.id"))
    trigger_conditions = Column(JSONB)
    
    # Actions
    actions = Column(JSONB, nullable=False)
    
    # Status
    is_active = Column(Boolean, default=True)
    last_executed_at = Column(DateTime)
    execution_count = Column(Integer, default=0)
    
    # Metadata
    created_by = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    executions = relationship("WorkflowExecution", back_populates="workflow", cascade="all, delete-orphan")


class WorkflowExecution(Base):
    """Workflow execution log."""
    __tablename__ = "workflow_executions"
    
    id = Column(Integer, primary_key=True, index=True)
    workflow_id = Column(Integer, ForeignKey("report_workflows.id"), nullable=False)
    
    # Execution details
    executed_at = Column(DateTime, default=datetime.utcnow)
    records_processed = Column(Integer)
    records_affected = Column(Integer)
    
    # Status
    status = Column(String(50), default='pending')
    error_message = Column(Text)
    execution_log = Column(JSONB)
    
    # Relationships
    workflow = relationship("ReportWorkflow", back_populates="executions")
======================================

======================================
File: event.py
Path: ./api/app/models
--------------------------------------
"""
Event and shift management models.
Supports both emergency and non-emergency activities.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Date, Time, Enum as SQLEnum
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from database import Base


class ActivityType(str, enum.Enum):
    """Event activity type from requirements."""
    EMERGENCY = "emergency"
    NON_EMERGENCY = "non_emergency"
    # Note: This enum is kept for backward compatibility but not used in the model
    # The database column uses VARCHAR(50) to allow flexible activity types


class EventStatus(str, enum.Enum):
    """Event status."""
    DRAFT = "draft"
    PUBLISHED = "published"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"


class AssignmentStatus(str, enum.Enum):
    """Volunteer assignment status."""
    PENDING = "pending"
    CONFIRMED = "confirmed"
    DECLINED = "declined"
    COMPLETED = "completed"
    NO_SHOW = "no_show"
    WAITLIST = "waitlist"  # New from requirements


class Event(Base):
    """
    Event model for volunteer opportunities and deployments.
    Supports both scheduled and emergency events.
    """
    __tablename__ = "events"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # Basic Information
    name = Column(String(255), nullable=False)
    staff_description = Column(Text)  # Description for coordinators
    volunteer_description = Column(Text)  # Description volunteers see
    location = Column(String(255))
    locality = Column(String(100))  # District/locality
    
    # Dates
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime)
    
    # Event Classification
    activity_type = Column(String(50), nullable=False)  # Changed from SQLEnum to String to match database VARCHAR(50)
    response_name = Column(String(255))  # e.g., "COVID-19 Response"
    mission_types = Column(Text)  # JSON array: ["Behavioral Health/Resiliency", "Infection Prevention Education"]
    requestor_type = Column(String(100))
    
    # Visibility and Configuration
    visible_to_volunteers = Column(Boolean, default=True)
    allow_self_signup = Column(Boolean, default=False)  # Sign-Up Genius feature
    enable_waitlist = Column(Boolean, default=False)  # New from requirements
    districts = Column(Text)  # JSON array of district names
    
    # Status
    status = Column(String(20), nullable=False, default='draft')  # Changed from SQLEnum to String to match database VARCHAR(20)
    
    # Impact Tracking (from requirements)
    impact_data = Column(Text)  # JSON: {"vaccines_administered": 150, "screenings": 75}
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by = Column(Integer, ForeignKey("users.id"))
    
    # Relationships
    tenant = relationship("Tenant", back_populates="events")
    shifts = relationship("Shift", back_populates="event", cascade="all, delete-orphan")
    assignments = relationship("EventAssignment", back_populates="event", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Event(id={self.id}, name='{self.name}', type='{self.activity_type}')>"


class Shift(Base):
    """
    Shift model for scheduled volunteer time blocks.
    Supports drag-and-drop creation and recurring templates.
    """
    __tablename__ = "shifts"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), nullable=False, index=True)
    
    # Shift Details
    name = Column(String(255), nullable=False)
    description = Column(Text)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    
    # Capacity
    max_volunteers = Column(Integer)
    min_volunteers = Column(Integer, default=1)
    
    # Requirements
    required_skills = Column(Text)
    location = Column(String(255))
    
    # Advanced scheduling features (ADD THESE IF MISSING)
    allow_self_signup = Column(Boolean, default=False)
    enable_waitlist = Column(Boolean, default=True)
    waitlist_capacity = Column(Integer, default=10)
    conflict_detection = Column(Boolean, default=True)
    template_id = Column(Integer, ForeignKey("shift_templates.id"))
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    event = relationship("Event", back_populates="shifts")
    assignments = relationship("EventAssignment", back_populates="shift")
    
    def __repr__(self):
        return f"<Shift(id={self.id}, name='{self.name}')>"


class EventAssignment(Base):
    """
    Junction table for volunteer event assignments.
    Tracks who is assigned to which shift/event.
    """
    __tablename__ = "event_assignments"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), nullable=False, index=True)
    shift_id = Column(Integer, ForeignKey("shifts.id"), index=True)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False, index=True)
    
    # Assignment Details
    status = Column(String(20), nullable=False, default='pending')  # Changed from SQLEnum to String
    assigned_by = Column(Integer, ForeignKey("users.id"))
    
    # Time Tracking
    check_in_time = Column(DateTime)
    check_out_time = Column(DateTime)
    hours_completed = Column(Integer, default=0)
    hours_served = Column(Integer, default=0)
    
    # Notes
    notes = Column(Text)
    coordinator_notes = Column(Text)
    volunteer_notes = Column(Text)
    
    # Timestamps
    assigned_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    confirmed_at = Column(DateTime)
    completed_at = Column(DateTime)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    event = relationship("Event", back_populates="assignments")
    shift = relationship("Shift", back_populates="assignments")
    volunteer = relationship("Volunteer", back_populates="event_assignments")
    
    def __repr__(self):
        return f"<EventAssignment(id={self.id}, volunteer_id={self.volunteer_id}, status='{self.status}')>"======================================

======================================
File: volunteer.py
Path: ./api/app/models
--------------------------------------
"""
Volunteer model with comprehensive profile management.
Enhanced to match the new database schema with all fields.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Date, Enum as SQLEnum, DECIMAL
from sqlalchemy.orm import relationship
from datetime import datetime, date
import enum
from database import Base


class VolunteerStatus(str, enum.Enum):
    """Volunteer application status."""
    APPROVED = "approved"
    PENDING = "pending"
    INCOMPLETE = "incomplete"
    WORKING = "working"
    REJECTED = "rejected"
    INACTIVE = "inactive"


class AccountStatus(str, enum.Enum):
    """Volunteer account status."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"


class MRCLevel(str, enum.Enum):
    """MRC Level classification."""
    LEVEL_1 = "level_1"
    LEVEL_2 = "level_2"
    LEVEL_3 = "level_3"


class Volunteer(Base):
    """
    Volunteer profile model - Enhanced version.
    Matches the enhanced database schema with all comprehensive fields.
    """
    __tablename__ = "volunteers"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    
    # Authentication (for volunteer portal)
    username = Column(String(100), nullable=False, unique=True, index=True)
    email = Column(String(255), nullable=False, index=True)
    hashed_password = Column(String(255))
    
    # Personal Information
    first_name = Column(String(100), nullable=False)
    middle_name = Column(String(100))
    last_name = Column(String(100), nullable=False)
    date_of_birth = Column(Date)
    
    # Contact Information
    phone_primary = Column(String(20))
    phone_secondary = Column(String(20))
    address_line1 = Column(String(255))
    address_line2 = Column(String(255))
    city = Column(String(100))
    state = Column(String(2), default="VA")
    zip_code = Column(String(10))
    
    # Emergency Contact
    emergency_contact_name = Column(String(255))
    emergency_contact_phone = Column(String(20))
    emergency_contact_relationship = Column(String(100))
    
    # Application Status
    application_status = Column(String(20), default='pending', index=True)
    account_status = Column(String(20), default='active')
    mrc_level = Column(String(20))
    
    # Professional Information
    occupation = Column(String(100))
    employer = Column(String(255))
    professional_skills = Column(Text)
    license_number = Column(String(100))
    license_type = Column(String(100))
    license_state = Column(String(2))
    license_expiration = Column(Date)
    
    # Skills and Languages
    skills = Column(Text)
    languages = Column(String(255))
    
    # Training and Credentials
    certifications = Column(Text)
    certification_info = Column(Text)
    train_id = Column(String(100))
    train_data = Column(Text)
    
    # Availability and Preferences
    availability = Column(Text)
    availability_info = Column(Text)
    travel_distance = Column(Integer, default=25)
    preferred_roles = Column(Text)
    assigned_groups = Column(Text)
    assigned_roles = Column(Text)
    
    # Metrics and Performance (stored directly now)
    total_hours = Column(DECIMAL(10, 2), default=0)
    alert_response_rate = Column(DECIMAL(5, 2), default=0)
    badges_earned = Column(Text)
    
    # Background Check
    background_check_date = Column(Date)
    background_check_status = Column(String(20))
    
    # Important Dates
    application_date = Column(DateTime, default=datetime.utcnow)
    approval_date = Column(DateTime)
    last_activity_date = Column(DateTime)
    
    # System Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_activity = Column(DateTime)  # Backward compatibility
    approved_at = Column(DateTime)    # Backward compatibility
    approved_by = Column(Integer, ForeignKey("users.id"))
    
    # Relationships
    tenant = relationship("Tenant", back_populates="volunteers")
    event_assignments = relationship("EventAssignment", back_populates="volunteer", lazy="dynamic")
    training_records = relationship("VolunteerTraining", back_populates="volunteer", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Volunteer(id={self.id}, name='{self.full_name}', status='{self.application_status}')>"
    
    @property
    def full_name(self):
        """Get volunteer's full name."""
        if self.middle_name:
            return f"{self.first_name} {self.middle_name} {self.last_name}"
        return f"{self.first_name} {self.last_name}"
    
    @property
    def status(self):
        """Alias for application_status for compatibility."""
        return self.application_status
    
    @property
    def phone(self):
        """Primary phone for compatibility."""
        return self.phone_primary
    
    @property
    def hours_completed(self):
        """Alias for total_hours for compatibility."""
        return self.total_hours or 0======================================

======================================
File: time_tracking.py
Path: ./api/app/models
--------------------------------------
# api/app/models/time_tracking.py
"""
Time tracking models for volunteer hours.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, DECIMAL
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base


class TimeEntry(Base):
    """
    Volunteer time entry/hours tracking.
    """
    __tablename__ = "time_entries"
    
    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False, index=True)
    event_id = Column(Integer, ForeignKey("events.id"))
    shift_id = Column(Integer, ForeignKey("shifts.id"))
    
    # Time tracking
    check_in_time = Column(DateTime, nullable=False)
    check_out_time = Column(DateTime)
    duration_minutes = Column(Integer)
    hours_decimal = Column(DECIMAL(5, 2))
    
    # Entry method
    entry_method = Column(String(50), nullable=False, default='manual')
    
    # Geolocation
    check_in_lat = Column(DECIMAL(10, 8))
    check_in_lng = Column(DECIMAL(11, 8))
    check_out_lat = Column(DECIMAL(10, 8))
    check_out_lng = Column(DECIMAL(11, 8))
    location_verified = Column(Boolean, default=False)
    
    # Approval workflow
    status = Column(String(50), nullable=False, default='pending', index=True)
    submitted_by = Column(Integer, ForeignKey("users.id"))
    approved_by = Column(Integer, ForeignKey("users.id"))
    approved_at = Column(DateTime)
    rejection_reason = Column(Text)
    
    # Notes
    volunteer_notes = Column(Text)
    coordinator_notes = Column(Text)
    dispute_notes = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    volunteer = relationship("Volunteer")
    event = relationship("Event")
    
    def calculate_duration(self):
        """Calculate duration in minutes and hours."""
        if self.check_out_time and self.check_in_time:
            delta = self.check_out_time - self.check_in_time
            self.duration_minutes = int(delta.total_seconds() / 60)
            self.hours_decimal = round(self.duration_minutes / 60, 2)
    
    def __repr__(self):
        return f"<TimeEntry(id={self.id}, volunteer={self.volunteer_id}, hours={self.hours_decimal})>"


class EventQRCode(Base):
    """
    QR codes for event/shift check-in.
    """
    __tablename__ = "event_qr_codes"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"))
    shift_id = Column(Integer, ForeignKey("shifts.id"))
    
    # QR Code data
    qr_code_hash = Column(String(255), unique=True, nullable=False, index=True)
    qr_code_url = Column(String(500))
    
    # Validity
    valid_from = Column(DateTime, nullable=False)
    valid_until = Column(DateTime, nullable=False)
    is_active = Column(Boolean, default=True)
    max_uses = Column(Integer)
    use_count = Column(Integer, default=0)
    
    # Configuration
    require_photo = Column(Boolean, default=False)
    require_signature = Column(Boolean, default=False)
    allow_early_checkin_minutes = Column(Integer, default=15)
    allow_late_checkout_minutes = Column(Integer, default=30)
    
    # Metadata
    created_by = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    event = relationship("Event")
    
    def is_valid(self) -> bool:
        """Check if QR code is currently valid."""
        now = datetime.utcnow()
        if not self.is_active:
            return False
        if now < self.valid_from or now > self.valid_until:
            return False
        if self.max_uses and self.use_count >= self.max_uses:
            return False
        return True
    
    def __repr__(self):
        return f"<EventQRCode(id={self.id}, event={self.event_id}, hash='{self.qr_code_hash[:20]}...')>"


class CheckinSession(Base):
    """
    Active check-in sessions for mobile/kiosk.
    """
    __tablename__ = "checkin_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    volunteer_id = Column(Integer, ForeignKey("volunteers.id"), nullable=False)
    event_id = Column(Integer, ForeignKey("events.id"))
    qr_code_id = Column(Integer, ForeignKey("event_qr_codes.id"))
    
    # Session data
    check_in_time = Column(DateTime, nullable=False)
    check_out_time = Column(DateTime)
    device_info = Column(Text)  # JSON string
    ip_address = Column(String(45))
    
    # Status
    status = Column(String(50), default='active')
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    volunteer = relationship("Volunteer")
    event = relationship("Event")
    
    def __repr__(self):
        return f"<CheckinSession(id={self.id}, volunteer={self.volunteer_id}, status='{self.status}')>"======================================

======================================
File: user.py
Path: ./api/app/schemas
--------------------------------------
"""
User schemas for staff and administrator management.
"""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime
from models.user import UserRole, UserStatus


class UserBase(BaseModel):
    """Base user schema."""
    username: str = Field(..., min_length=3, max_length=100)
    email: EmailStr
    first_name: str = Field(..., min_length=1, max_length=100)
    last_name: str = Field(..., min_length=1, max_length=100)
    phone: Optional[str] = None
    role: UserRole = UserRole.SUB_UNIT_STAFF


class UserCreate(UserBase):
    """Schema for creating a new user."""
    password: str = Field(..., min_length=8)
    tenant_id: int
    
    # Sub-unit staff permissions (radio buttons from requirements)
    can_view_data: bool = True
    can_edit_data: bool = False
    can_send_password_reminder: bool = False
    can_initiate_transfers: bool = False
    can_approve_transfers: bool = False
    can_view_alerts: bool = True
    can_edit_alerts: bool = False
    can_export_data: bool = False


class UserUpdate(BaseModel):
    """Schema for updating user."""
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None
    role: Optional[UserRole] = None
    status: Optional[UserStatus] = None
    
    # Permissions
    can_view_data: Optional[bool] = None
    can_edit_data: Optional[bool] = None
    can_send_password_reminder: Optional[bool] = None
    can_initiate_transfers: Optional[bool] = None
    can_approve_transfers: Optional[bool] = None
    can_view_alerts: Optional[bool] = None
    can_edit_alerts: Optional[bool] = None
    can_export_data: Optional[bool] = None


class UserResponse(UserBase):
    """Schema for user response."""
    id: int
    tenant_id: int
    status: UserStatus
    mfa_enabled: bool
    last_login: Optional[datetime]
    created_at: datetime
    
    # Permissions
    can_view_data: bool
    can_edit_data: bool
    can_send_password_reminder: bool
    can_initiate_transfers: bool
    can_approve_transfers: bool
    can_view_alerts: bool
    can_edit_alerts: bool
    can_export_data: bool
    
    class Config:
        from_attributes = True


class UserListResponse(BaseModel):
    """Schema for user list response."""
    total: int
    items: list[UserResponse]
======================================

======================================
File: document.py
Path: ./api/app/schemas
--------------------------------------
# api/app/schemas/document.py
"""
Pydantic schemas for document management.
"""
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime, date
from enum import Enum


class DocumentType(str, Enum):
    """Document type enumeration."""
    PHOTO_ID = "photo_id"
    DRIVERS_LICENSE = "drivers_license"
    PROFESSIONAL_LICENSE = "professional_license"
    CERTIFICATION = "certification"
    INSURANCE = "insurance"
    WAIVER = "waiver"
    POLICY = "policy"
    OTHER = "other"


class SignatureMethod(str, Enum):
    """Signature capture method."""
    DRAWN = "drawn"
    TYPED = "typed"
    CLICK_THROUGH = "click_through"
    BIOMETRIC = "biometric"


class VerificationStatus(str, Enum):
    """Document verification status."""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    EXPIRED = "expired"


# ============ Policy Documents ============

class PolicyDocumentBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    document_type: str
    version: str
    requires_signature: bool = False
    effective_date: Optional[date] = None
    expiration_date: Optional[date] = None


class PolicyDocumentCreate(PolicyDocumentBase):
    tenant_id: int
    file_url: str
    file_size_bytes: Optional[int] = None
    file_hash: Optional[str] = None


class PolicyDocumentUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    is_active: Optional[bool] = None
    expiration_date: Optional[date] = None


class PolicyDocumentResponse(PolicyDocumentBase):
    id: int
    tenant_id: int
    file_url: str
    file_size_bytes: Optional[int]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    is_expired: bool
    
    class Config:
        from_attributes = True


# ============ Electronic Signatures ============

class ElectronicSignatureCreate(BaseModel):
    # What to sign
    policy_document_id: Optional[int] = None
    custom_document_id: Optional[int] = None
    
    # Signature data
    signature_data: Optional[str] = None  # Base64 encoded image
    signature_method: SignatureMethod
    
    # Consent
    consent_text: str
    acknowledged_terms: bool = True
    
    # Location (optional)
    geolocation: Optional[dict] = None
    
    @validator('policy_document_id', 'custom_document_id')
    def check_document_id(cls, v, values):
        """Ensure at least one document ID is provided."""
        if not v and not values.get('policy_document_id') and not values.get('custom_document_id'):
            raise ValueError('Must specify either policy_document_id or custom_document_id')
        return v


class ElectronicSignatureResponse(BaseModel):
    id: int
    volunteer_id: Optional[int]
    user_id: Optional[int]
    policy_document_id: Optional[int]
    custom_document_id: Optional[int]
    signature_method: str
    timestamp: datetime
    ip_address: str
    verified: bool
    
    class Config:
        from_attributes = True


# ============ Volunteer Documents ============

class VolunteerDocumentBase(BaseModel):
    document_type: DocumentType
    document_category: Optional[str] = None
    title: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    issue_date: Optional[date] = None
    expiration_date: Optional[date] = None
    expires: bool = False


class VolunteerDocumentCreate(VolunteerDocumentBase):
    volunteer_id: int
    file_url: str
    file_name: str
    file_size_bytes: int
    file_type: str
    file_hash: Optional[str] = None


class VolunteerDocumentUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    expiration_date: Optional[date] = None
    verification_status: Optional[VerificationStatus] = None
    rejection_reason: Optional[str] = None


class VolunteerDocumentResponse(VolunteerDocumentBase):
    id: int
    volunteer_id: int
    tenant_id: int
    file_url: str
    file_name: str
    file_size_bytes: int
    file_type: str
    verification_status: str
    verified_at: Optional[datetime]
    uploaded_at: datetime
    is_expired: bool
    days_until_expiration: int
    download_count: int
    
    class Config:
        from_attributes = True


# ============ Document Access ============

class DocumentAccessLogCreate(BaseModel):
    document_id: int
    document_type: str  # 'policy_document' or 'volunteer_document'
    action: str  # view, download, upload, delete, sign
    meta_data: Optional[dict] = None


# ============ Reports ============

class ExpiringDocumentReport(BaseModel):
    """Report of documents expiring soon."""
    volunteer_id: int
    volunteer_name: str
    document_type: str
    document_title: str
    expiration_date: date
    days_until_expiration: int


class SignatureLogResponse(BaseModel):
    """Signature history for a document."""
    document_id: int
    document_title: str
    signatures: List[ElectronicSignatureResponse]
    unsigned_volunteers: List[dict]  # Volunteers who need to sign


# ============ File Upload ============

class DocumentUploadRequest(BaseModel):
    """Request for S3 presigned URL."""
    volunteer_id: int
    document_type: DocumentType
    file_name: str
    file_size_bytes: int
    file_type: str


class DocumentUploadResponse(BaseModel):
    """Response with presigned URL for upload."""
    upload_url: str
    document_id: int
    expires_in: int  # Seconds
======================================

======================================
File: tenant.py
Path: ./api/app/schemas
--------------------------------------
"""
Tenant schemas for multi-tenant SaaS management.
"""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime


class TenantBase(BaseModel):
    """Base tenant schema."""
    name: str = Field(..., min_length=1, max_length=255)
    slug: str = Field(..., min_length=1, max_length=100, pattern="^[a-z0-9-]+$")
    contact_email: EmailStr
    contact_phone: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: str = "VA"
    zip_code: Optional[str] = None


class TenantCreate(TenantBase):
    """Schema for creating a new tenant."""
    pass


class TenantUpdate(BaseModel):
    """Schema for updating tenant."""
    name: Optional[str] = None
    contact_email: Optional[EmailStr] = None
    contact_phone: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip_code: Optional[str] = None
    is_active: Optional[bool] = None


class TenantResponse(TenantBase):
    """Schema for tenant response."""
    id: int
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


class TenantListResponse(BaseModel):
    """Schema for tenant list response."""
    total: int
    items: list[TenantResponse]
======================================

======================================
File: training.py
Path: ./api/app/schemas
--------------------------------------
# api/app/schemas/training.py
"""
Training and certification schemas.
"""
from pydantic import BaseModel
from typing import Optional
from datetime import date, datetime
from decimal import Decimal


# ============ Training Courses ============

class TrainingCourseBase(BaseModel):
    name: str
    description: Optional[str] = None
    course_code: Optional[str] = None
    provider: Optional[str] = None
    category: Optional[str] = None
    is_required: bool = False
    validity_period_days: Optional[int] = None


class TrainingCourseCreate(TrainingCourseBase):
    tenant_id: int
    train_course_id: Optional[str] = None


class TrainingCourseResponse(TrainingCourseBase):
    id: int
    tenant_id: int
    train_course_id: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True


# ============ Volunteer Training ============

class VolunteerTrainingBase(BaseModel):
    course_id: int
    completion_date: date
    expiration_date: Optional[date] = None
    score: Optional[Decimal] = None
    certificate_number: Optional[str] = None


class VolunteerTrainingCreate(VolunteerTrainingBase):
    volunteer_id: int
    certificate_url: Optional[str] = None


class VolunteerTrainingResponse(VolunteerTrainingBase):
    id: int
    volunteer_id: int
    status: str
    train_completion_id: Optional[str]
    synced_from_train: bool
    is_expired: bool
    created_at: datetime
    
    # Include course details
    course_name: Optional[str] = None
    course_provider: Optional[str] = None
    course_category: Optional[str] = None
    
    class Config:
        from_attributes = True


# ============ Certifications ============

class CertificationBase(BaseModel):
    certification_type: str
    license_number: Optional[str] = None
    issuing_authority: Optional[str] = None
    issue_date: Optional[date] = None
    expiration_date: Optional[date] = None
    notes: Optional[str] = None


class CertificationCreate(CertificationBase):
    volunteer_id: int
    document_url: Optional[str] = None


class CertificationUpdate(BaseModel):
    expiration_date: Optional[date] = None
    verification_status: Optional[str] = None
    notes: Optional[str] = None


class CertificationResponse(CertificationBase):
    id: int
    volunteer_id: int
    verification_status: str
    verification_date: Optional[date]
    is_expired: bool
    days_until_expiration: int
    created_at: datetime
    
    class Config:
        from_attributes = True


# ============ Training Status ============

class TrainingStatusSummary(BaseModel):
    """Summary of volunteer's training status."""
    volunteer_id: int
    total_courses: int
    completed_courses: int
    expired_courses: int
    expiring_soon: int  # Within 90 days
    compliance_percentage: float
    missing_required: list[str]


class ExpiringTrainingReport(BaseModel):
    """Report of expiring training."""
    volunteer_id: int
    volunteer_name: str
    course_name: str
    expiration_date: date
    days_until_expiration: int
    is_required: bool


# ============ TRAIN Sync ============

class TRAINSyncRequest(BaseModel):
    """Request to sync training from TRAIN."""
    volunteer_id: Optional[int] = None  # If None, sync all
    force: bool = False  # Force re-sync


class TRAINSyncResponse(BaseModel):
    """Response from TRAIN sync."""
    success: bool
    records_synced: int
    errors: list[str]
    message: str======================================

======================================
File: auth.py
Path: ./api/app/schemas
--------------------------------------
"""
Authentication schemas for request/response validation.
"""
from pydantic import BaseModel, EmailStr
from typing import Optional


class Token(BaseModel):
    """JWT token response."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    """Decoded token data."""
    user_id: Optional[int] = None
    username: Optional[str] = None
    tenant_id: Optional[int] = None
    role: Optional[str] = None


class LoginRequest(BaseModel):
    """Login request payload."""
    username: str
    password: str


class RefreshTokenRequest(BaseModel):
    """Refresh token request."""
    refresh_token: str


class ChangePasswordRequest(BaseModel):
    """Change password request."""
    current_password: str
    new_password: str


class ResetPasswordRequest(BaseModel):
    """Password reset request."""
    email: EmailStr


class ResetPasswordConfirm(BaseModel):
    """Password reset confirmation."""
    token: str
    new_password: str
======================================

======================================
File: scheduling.py
Path: ./api/app/schemas
--------------------------------------
"""
Schemas for advanced scheduling features.
"""
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime, date, time
from enum import Enum


class RecurrenceFrequency(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class WaitlistStatus(str, Enum):
    WAITING = "waiting"
    PROMOTED = "promoted"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class SwapRequestStatus(str, Enum):
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class AvailabilityType(str, Enum):
    GENERAL = "general"
    SPECIFIC_EVENT = "specific_event"
    BLACKOUT = "blackout"


# Shift Template Schemas
class RecurrencePattern(BaseModel):
    frequency: RecurrenceFrequency
    days: List[int]  # 0=Sunday, 1=Monday, etc.
    interval: int = 1  # Every X weeks/months
    until: Optional[date] = None


class ShiftTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    recurrence_pattern: Optional[RecurrencePattern] = None
    duration_minutes: int = Field(..., gt=0)
    max_volunteers: Optional[int] = Field(None, gt=0)
    min_volunteers: int = Field(1, gt=0)
    required_skills: Optional[List[str]] = None
    required_training: Optional[List[str]] = None
    allow_self_signup: bool = False
    enable_waitlist: bool = True


class ShiftTemplateCreate(ShiftTemplateBase):
    tenant_id: int


class ShiftTemplateResponse(ShiftTemplateBase):
    id: int
    tenant_id: int
    is_active: bool
    created_by: Optional[int]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# Waitlist Schemas
class WaitlistJoinRequest(BaseModel):
    shift_id: int
    notes: Optional[str] = None
    auto_accept: bool = False


class WaitlistResponse(BaseModel):
    id: int
    shift_id: int
    volunteer_id: int
    position: int
    priority_score: int
    status: WaitlistStatus
    joined_at: datetime
    promoted_at: Optional[datetime]
    notified_at: Optional[datetime]
    notes: Optional[str]
    
    # Include volunteer info
    volunteer_name: Optional[str] = None
    volunteer_email: Optional[str] = None
    
    class Config:
        from_attributes = True


# Availability Schemas
class AvailabilityBase(BaseModel):
    start_date: date
    end_date: date
    start_time: Optional[time] = None
    end_time: Optional[time] = None
    recurrence_pattern: Optional[RecurrencePattern] = None
    availability_type: AvailabilityType = AvailabilityType.GENERAL
    event_id: Optional[int] = None
    notes: Optional[str] = None


class AvailabilityCreate(AvailabilityBase):
    pass


class AvailabilityUpdate(BaseModel):
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    start_time: Optional[time] = None
    end_time: Optional[time] = None
    is_active: Optional[bool] = None
    notes: Optional[str] = None


class AvailabilityResponse(AvailabilityBase):
    id: int
    volunteer_id: int
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# Shift Swap Schemas
class SwapRequestCreate(BaseModel):
    original_assignment_id: int
    target_volunteer_id: Optional[int] = None
    reason: Optional[str] = None


class SwapRequestResponse(BaseModel):
    id: int
    original_assignment_id: int
    requesting_volunteer_id: int
    target_volunteer_id: Optional[int]
    status: SwapRequestStatus
    approved_by: Optional[int]
    approved_at: Optional[datetime]
    rejection_reason: Optional[str]
    reason: Optional[str]
    created_at: datetime
    
    # Include details
    shift_name: Optional[str] = None
    shift_date: Optional[datetime] = None
    requesting_volunteer_name: Optional[str] = None
    target_volunteer_name: Optional[str] = None
    
    class Config:
        from_attributes = True


# Enhanced Shift Schemas
class ShiftSelfSignupRequest(BaseModel):
    shift_id: int
    notes: Optional[str] = None


class AvailableShiftResponse(BaseModel):
    id: int
    event_id: int
    name: str
    start_time: datetime
    end_time: datetime
    location: Optional[str]
    max_volunteers: Optional[int]
    current_volunteers: int
    available_spots: int
    waitlist_count: int
    allow_self_signup: bool
    enable_waitlist: bool
    required_skills: Optional[List[str]]
    
    # Event details
    event_name: str
    event_description: Optional[str]
    
    class Config:
        from_attributes = True


# Bulk Operations
class BulkShiftCreateRequest(BaseModel):
    template_id: int
    event_id: int
    start_date: date
    end_date: date
    location: Optional[str] = None


class BulkShiftCreateResponse(BaseModel):
    created_count: int
    shifts_created: List[int]
    message: str======================================

======================================
File: reporting.py
Path: ./api/app/schemas
--------------------------------------
# api/app/schemas/reporting.py
"""
Reporting and analytics schemas.
"""
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum


class ReportType(str, Enum):
    """Report types."""
    VOLUNTEER_HOURS = "volunteer_hours"
    IMPACT_DATA = "impact_data"
    COMPLIANCE = "compliance"
    UNIT_METRICS = "unit_metrics"
    CUSTOM = "custom"


class AggregationFunction(str, Enum):
    """Aggregation functions."""
    COUNT = "count"
    SUM = "sum"
    AVG = "avg"
    MIN = "min"
    MAX = "max"


class ExportFormat(str, Enum):
    """Export formats."""
    EXCEL = "excel"
    PDF = "pdf"
    CSV = "csv"
    JSON = "json"


# ============ Report Configuration ============

class FilterCondition(BaseModel):
    """Filter condition for report."""
    field: str
    operator: str  # eq, ne, gt, lt, gte, lte, in, contains
    value: Any


class GroupByConfig(BaseModel):
    """Grouping configuration."""
    field: str
    aggregation: Optional[AggregationFunction] = None


class QueryConfig(BaseModel):
    """Report query configuration."""
    entity_type: str
    fields: List[str]
    filters: Optional[List[FilterCondition]] = []
    group_by: Optional[List[GroupByConfig]] = []
    order_by: Optional[List[Dict[str, str]]] = []
    limit: Optional[int] = None


class VisualizationConfig(BaseModel):
    """Chart/visualization configuration."""
    chart_type: str  # bar, line, pie, table
    x_axis: Optional[str] = None
    y_axis: Optional[str] = None
    colors: Optional[List[str]] = None


class ScheduleConfig(BaseModel):
    """Report scheduling configuration."""
    frequency: str  # daily, weekly, monthly
    time: str  # HH:MM
    timezone: str = "America/New_York"
    recipients: List[str]  # Email addresses
    format: ExportFormat = ExportFormat.EXCEL


# ============ Saved Reports ============

class SavedReportCreate(BaseModel):
    """Create saved report."""
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    report_type: ReportType
    query_config: QueryConfig
    visualization_config: Optional[VisualizationConfig] = None
    schedule_config: Optional[ScheduleConfig] = None
    is_public: bool = False
    shared_with_roles: Optional[List[str]] = []
    shared_with_users: Optional[List[int]] = []


class SavedReportUpdate(BaseModel):
    """Update saved report."""
    name: Optional[str] = None
    description: Optional[str] = None
    query_config: Optional[QueryConfig] = None
    visualization_config: Optional[VisualizationConfig] = None
    schedule_config: Optional[ScheduleConfig] = None
    is_public: Optional[bool] = None
    is_active: Optional[bool] = None


class SavedReportResponse(BaseModel):
    """Saved report response."""
    id: int
    tenant_id: int
    name: str
    description: Optional[str]
    report_type: str
    query_config: Dict[str, Any]
    visualization_config: Optional[Dict[str, Any]]
    schedule_config: Optional[Dict[str, Any]]
    is_public: bool
    created_by: int
    created_at: datetime
    updated_at: datetime
    is_active: bool
    last_generated_at: Optional[datetime]
    
    class Config:
        from_attributes = True


# ============ Report Execution ============

class ExecuteReportRequest(BaseModel):
    """Execute report request."""
    export_format: ExportFormat = ExportFormat.EXCEL
    email_to: Optional[List[str]] = None


class ReportExecutionResponse(BaseModel):
    """Report execution response."""
    id: int
    report_id: int
    executed_by: int
    executed_at: datetime
    execution_time_ms: int
    row_count: int
    file_url: Optional[str]
    file_format: str
    status: str
    
    class Config:
        from_attributes = True


# ============ Report Results ============

class ReportResultsResponse(BaseModel):
    """Report results response."""
    columns: List[str]
    rows: List[Dict[str, Any]]
    total_count: int
    execution_time_ms: int
    aggregations: Optional[Dict[str, Any]] = None


# ============ Workflow Automation ============

class WorkflowAction(BaseModel):
    """Workflow action configuration."""
    type: str  # add_to_group, send_email, award_badge, etc.
    config: Dict[str, Any]


class WorkflowCreate(BaseModel):
    """Create workflow."""
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    trigger_report_id: int
    trigger_conditions: Optional[List[FilterCondition]] = []
    actions: List[WorkflowAction]


class WorkflowResponse(BaseModel):
    """Workflow response."""
    id: int
    tenant_id: int
    name: str
    description: Optional[str]
    trigger_report_id: int
    trigger_conditions: Optional[List[Dict[str, Any]]]
    actions: List[Dict[str, Any]]
    is_active: bool
    last_executed_at: Optional[datetime]
    execution_count: int
    created_at: datetime
    
    class Config:
        from_attributes = True


# ============ Pre-built Reports ============

class VolunteerHoursReport(BaseModel):
    """Volunteer hours report results."""
    volunteer_id: int
    volunteer_name: str
    total_hours: float
    approved_hours: float
    pending_hours: float
    events_attended: int
    date_range_start: Optional[datetime]
    date_range_end: Optional[datetime]


class ImpactDataReport(BaseModel):
    """Impact data report results."""
    event_id: int
    event_name: str
    event_date: datetime
    volunteers_assigned: int
    total_hours: float
    impact_metrics: Dict[str, Any]  # vaccines_administered, meals_distributed, etc.


class ComplianceReport(BaseModel):
    """Compliance report results."""
    volunteer_id: int
    volunteer_name: str
    required_trainings: List[str]
    completed_trainings: List[str]
    missing_trainings: List[str]
    expired_certifications: List[str]
    compliance_percentage: float


class UnitMetricsReport(BaseModel):
    """Unit-level metrics report."""
    unit_name: str
    total_volunteers: int
    active_volunteers: int
    total_events: int
    total_hours_served: float
    average_hours_per_volunteer: float
    retention_rate: float
    period_start: datetime
    period_end: datetime
======================================

======================================
File: event.py
Path: ./api/app/schemas
--------------------------------------
"""
Event schemas for request/response validation.
"""
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from models.event import ActivityType, EventStatus

class EventBase(BaseModel):
    """Base event schema."""
    name: str = Field(..., min_length=1, max_length=255)
    staff_description: Optional[str] = None
    volunteer_description: Optional[str] = None
    location: Optional[str] = None
    locality: Optional[str] = None
    start_date: datetime
    end_date: Optional[datetime] = None
    activity_type: ActivityType
    visible_to_volunteers: bool = True
    allow_self_signup: bool = False

class EventCreate(EventBase):
    """Schema for creating an event."""
    tenant_id: int
    response_name: Optional[str] = None
    requestor_type: Optional[str] = None

class EventUpdate(BaseModel):
    """Schema for updating event."""
    name: Optional[str] = None
    staff_description: Optional[str] = None
    volunteer_description: Optional[str] = None
    location: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    visible_to_volunteers: Optional[bool] = None
    status: Optional[EventStatus] = None

class EventResponse(EventBase):
    """Schema for event response."""
    id: int
    tenant_id: int
    status: EventStatus
    created_at: datetime
    updated_at: Optional[datetime]
    created_by: Optional[int]
    
    # Computed fields for frontend compatibility
    title: str = None  # Will be populated from 'name'
    event_date: str = None  # Will be populated from 'start_date'
    max_volunteers: Optional[int] = None
    registered_volunteers: int = 0
    
    class Config:
        from_attributes = True
        
    def __init__(self, **data):
        super().__init__(**data)
        # Map backend fields to frontend expectations
        self.title = data.get('name', '')
        if data.get('start_date'):
            self.event_date = data['start_date'].isoformat()

class EventListResponse(BaseModel):
    """Schema for event list response."""
    total: int
    items: List[EventResponse]

# For frontend compatibility - simplified response
class EventSimpleResponse(BaseModel):
    """Simplified event response matching frontend expectations exactly."""
    id: str
    tenant_id: str
    title: str
    description: Optional[str] = None
    event_date: str
    location: Optional[str] = None
    max_volunteers: Optional[int] = None
    registered_volunteers: int = 0
    created_by: str======================================

======================================
File: volunteer.py
Path: ./api/app/schemas
--------------------------------------
"""
Volunteer schemas for profile management.
FIXED: Proper field types matching the database DECIMAL fields.
"""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime, date
from decimal import Decimal


# Add this new schema for public registration
class PublicVolunteerRegistration(BaseModel):
    """Public volunteer self-registration schema - no authentication required"""
    # Tenant selection
    tenant_id: int
    
    # Step 1: Basic Information
    first_name: str = Field(..., min_length=1, max_length=100)
    middle_name: Optional[str] = None
    last_name: str = Field(..., min_length=1, max_length=100)
    email: EmailStr
    phone_primary: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: str = "VA"
    zip_code: Optional[str] = None
    
    # Step 2: Emergency Contact
    emergency_contact_name: Optional[str] = None
    emergency_contact_phone: Optional[str] = None
    emergency_contact_relationship: Optional[str] = None
    
    # Step 3: Skills and Availability
    skills: Optional[str] = None
    languages: Optional[str] = None
    availability: Optional[str] = None
    occupation: Optional[str] = None
    
    # Password
    password: str = Field(..., min_length=8)


class RegistrationSuccessResponse(BaseModel):
    """Response after successful registration"""
    message: str
    volunteer_id: int
    email: str
    status: str


class VolunteerBase(BaseModel):
    """Base volunteer schema."""
    username: str = Field(..., min_length=3, max_length=100)
    email: EmailStr
    first_name: str = Field(..., min_length=1, max_length=100)
    middle_name: Optional[str] = None
    last_name: str = Field(..., min_length=1, max_length=100)
    date_of_birth: Optional[date] = None
    
    # Contact
    phone_primary: Optional[str] = None
    phone_secondary: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: str = "VA"
    zip_code: Optional[str] = None
    
    # Emergency Contact
    emergency_contact_name: Optional[str] = None
    emergency_contact_phone: Optional[str] = None
    emergency_contact_relationship: Optional[str] = None


class VolunteerCreate(VolunteerBase):
    """Schema for creating volunteer."""
    password: str = Field(..., min_length=8)
    tenant_id: int
    mrc_level: Optional[str] = None


class VolunteerUpdate(BaseModel):
    """Schema for updating volunteer."""
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    middle_name: Optional[str] = None
    last_name: Optional[str] = None
    date_of_birth: Optional[date] = None
    phone_primary: Optional[str] = None
    phone_secondary: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip_code: Optional[str] = None
    
    application_status: Optional[str] = None
    account_status: Optional[str] = None
    mrc_level: Optional[str] = None


class VolunteerResponse(BaseModel):
    """Schema for volunteer response - matches actual DB fields with proper types."""
    id: int
    tenant_id: int
    username: str
    email: str
    first_name: str
    middle_name: Optional[str] = None
    last_name: str
    date_of_birth: Optional[date] = None
    
    # Contact
    phone_primary: Optional[str] = None
    phone_secondary: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip_code: Optional[str] = None
    
    # Emergency Contact  
    emergency_contact_name: Optional[str] = None
    emergency_contact_phone: Optional[str] = None
    emergency_contact_relationship: Optional[str] = None
    
    # Status fields - all optional
    application_status: Optional[str] = None
    account_status: Optional[str] = None
    mrc_level: Optional[str] = None  # This must be optional
    
    # Professional Information
    occupation: Optional[str] = None
    employer: Optional[str] = None
    professional_skills: Optional[str] = None
    license_number: Optional[str] = None
    license_type: Optional[str] = None
    license_state: Optional[str] = None
    license_expiration: Optional[date] = None
    
    # Skills and Languages
    skills: Optional[str] = None
    languages: Optional[str] = None
    
    # Training
    certifications: Optional[str] = None
    certification_info: Optional[str] = None
    train_id: Optional[str] = None
    train_data: Optional[str] = None
    
    # Availability
    availability: Optional[str] = None
    availability_info: Optional[str] = None
    travel_distance: Optional[int] = None
    preferred_roles: Optional[str] = None
    assigned_groups: Optional[str] = None
    assigned_roles: Optional[str] = None
    
    # Metrics - DECIMAL fields in DB, so use float/Decimal
    total_hours: Optional[float] = 0  # Changed from int to float
    alert_response_rate: Optional[float] = 0  # Changed from int to float
    badges_earned: Optional[str] = None
    
    # Background Check
    background_check_date: Optional[date] = None
    background_check_status: Optional[str] = None
    
    # Important Dates
    application_date: Optional[datetime] = None
    approval_date: Optional[datetime] = None
    last_activity_date: Optional[datetime] = None
    
    # System Timestamps
    created_at: datetime
    updated_at: Optional[datetime] = None
    last_activity: Optional[datetime] = None
    approved_at: Optional[datetime] = None
    approved_by: Optional[int] = None
    
    # Computed properties for frontend compatibility
    @property
    def status(self) -> str:
        return self.application_status or "unknown"
    
    @property
    def phone(self) -> Optional[str]:
        return self.phone_primary
    
    @property
    def hours_completed(self) -> float:
        return self.total_hours or 0
    
    class Config:
        from_attributes = True


class VolunteerListResponse(BaseModel):
    """Schema for volunteer list response."""
    total: int
    items: list[VolunteerResponse]


class VolunteerStatsResponse(BaseModel):
    """Dashboard statistics for volunteers."""
    total_volunteers: int
    approved_volunteers: int
    pending_applications: int
    incomplete_applications: int
    working_volunteers: int======================================

======================================
File: time_tracking.py
Path: ./api/app/schemas
--------------------------------------
# api/app/schemas/time_tracking.py
"""
Time tracking schemas.
"""
from pydantic import BaseModel, validator
from typing import Optional
from datetime import datetime
from decimal import Decimal


# ============ Time Entries ============

class TimeEntryBase(BaseModel):
    event_id: Optional[int] = None
    shift_id: Optional[int] = None
    check_in_time: datetime
    check_out_time: Optional[datetime] = None
    volunteer_notes: Optional[str] = None


class TimeEntryCreate(TimeEntryBase):
    volunteer_id: int
    entry_method: str = 'manual'
    
    # Optional geolocation
    check_in_lat: Optional[Decimal] = None
    check_in_lng: Optional[Decimal] = None
    check_out_lat: Optional[Decimal] = None
    check_out_lng: Optional[Decimal] = None


class TimeEntryBulkCreate(BaseModel):
    """Bulk time entry for multiple volunteers."""
    event_id: Optional[int] = None
    entries: list[dict]  # [{volunteer_id, check_in_time, check_out_time, notes}]


class TimeEntryUpdate(BaseModel):
    check_out_time: Optional[datetime] = None
    coordinator_notes: Optional[str] = None
    status: Optional[str] = None
    rejection_reason: Optional[str] = None


class TimeEntryResponse(BaseModel):
    id: int
    tenant_id: int
    volunteer_id: int
    event_id: Optional[int]
    shift_id: Optional[int]
    check_in_time: datetime
    check_out_time: Optional[datetime]
    duration_minutes: Optional[int]
    hours_decimal: Optional[float]
    entry_method: str
    status: str
    approved_by: Optional[int]
    approved_at: Optional[datetime]
    volunteer_notes: Optional[str]
    coordinator_notes: Optional[str]
    created_at: datetime
    
    # Include volunteer details
    volunteer_name: Optional[str] = None
    event_name: Optional[str] = None
    
    class Config:
        from_attributes = True


class TimeEntryApproval(BaseModel):
    """Approve or reject time entry."""
    status: str  # approved, rejected
    coordinator_notes: Optional[str] = None
    rejection_reason: Optional[str] = None
    hours_override: Optional[Decimal] = None  # Allow coordinator to adjust hours


class BulkTimeEntryApproval(BaseModel):
    """Bulk approve/reject multiple entries."""
    entry_ids: list[int]
    action: str  # approve, reject
    notes: Optional[str] = None


# ============ QR Codes ============

class QRCodeCreate(BaseModel):
    event_id: Optional[int] = None
    shift_id: Optional[int] = None
    valid_from: datetime
    valid_until: datetime
    max_uses: Optional[int] = None
    require_photo: bool = False
    require_signature: bool = False
    allow_early_checkin_minutes: int = 15
    allow_late_checkout_minutes: int = 30


class QRCodeResponse(BaseModel):
    id: int
    event_id: Optional[int]
    shift_id: Optional[int]
    qr_code_hash: str
    qr_code_url: str
    valid_from: datetime
    valid_until: datetime
    is_active: bool
    use_count: int
    max_uses: Optional[int]
    created_at: datetime
    
    # Include event details
    event_name: Optional[str] = None
    
    class Config:
        from_attributes = True


# ============ Check-in ============

class CheckinRequest(BaseModel):
    """Volunteer check-in via QR code or kiosk."""
    qr_code_hash: Optional[str] = None
    volunteer_id: Optional[int] = None
    event_id: Optional[int] = None
    device_info: Optional[dict] = None
    latitude: Optional[Decimal] = None
    longitude: Optional[Decimal] = None


class CheckoutRequest(BaseModel):
    """Volunteer check-out."""
    session_id: Optional[int] = None
    time_entry_id: Optional[int] = None
    latitude: Optional[Decimal] = None
    longitude: Optional[Decimal] = None
    notes: Optional[str] = None


class CheckinResponse(BaseModel):
    """Response after check-in."""
    success: bool
    message: str
    session_id: Optional[int] = None
    time_entry_id: Optional[int] = None
    volunteer_name: str
    event_name: Optional[str] = None
    check_in_time: datetime


# ============ Reports ============

class VolunteerHoursReport(BaseModel):
    """Volunteer hours summary."""
    volunteer_id: int
    volunteer_name: str
    total_hours: float
    approved_hours: float
    pending_hours: float
    entry_count: int
    date_range_start: Optional[datetime]
    date_range_end: Optional[datetime]


class PendingApprovalsReport(BaseModel):
    """Summary of pending hour approvals."""
    total_pending: int
    total_hours_pending: float
    oldest_entry_date: Optional[datetime]
    entries: list[TimeEntryResponse]======================================

======================================
File: deps.py
Path: ./api/app/api
--------------------------------------
"""
Simplified dependency injection for FastAPI endpoints.
"""
from typing import Optional
from fastapi import Depends, HTTPException, status, Request
from jose import JWTError
from sqlalchemy.orm import Session

from database import get_db
from core.security import decode_token
from core.permissions import has_permission, Permission
from models.user import User, UserRole
from schemas.auth import TokenData


def get_current_user(
    request: Request,
    db: Session = Depends(get_db)
) -> User:
    """
    Get current authenticated user from JWT token.
    Simplified version that extracts token from Authorization header.
    """
    # Get Authorization header
    auth_header = request.headers.get("Authorization")
    
    if not auth_header:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authenticated"
        )
    
    # Extract token (expecting "Bearer <token>")
    try:
        scheme, token = auth_header.split()
        if scheme.lower() != "bearer":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Invalid authentication scheme"
            )
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid authorization header format"
        )
    
    # Decode token
    try:
        payload = decode_token(token)
        user_id: int = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
            
        token_data = TokenData(
            user_id=user_id,
            username=payload.get("username"),
            tenant_id=payload.get("tenant_id"),
            role=payload.get("role")
        )
    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )
    
    # Get user from database
    user = db.query(User).filter(User.id == token_data.user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    
    # Check if user is active
    if user.status != "active":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"User account is not active (status: {user.status})"
        )
    
    return user


def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Ensure user is active."""
    if current_user.status != "active":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user


def require_permission(permission: str):
    """
    Dependency factory for permission checking.
    """
    def permission_checker(current_user: User = Depends(get_current_user)):
        user_permissions = {
            "can_edit_data": current_user.can_edit_data,
            "can_edit_alerts": current_user.can_edit_alerts,
            "can_initiate_transfers": current_user.can_initiate_transfers,
            "can_approve_transfers": current_user.can_approve_transfers,
            "can_export_data": current_user.can_export_data,
        }
        
        if not has_permission(current_user.role, permission, user_permissions):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission}"
            )
        return current_user
    
    return permission_checker


def require_role(allowed_roles: list[UserRole]):
    """
    Dependency factory for role checking.
    """
    def role_checker(current_user: User = Depends(get_current_user)):
        if current_user.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient privileges"
            )
        return current_user
    
    return role_checker======================================

======================================
File: documents.py
Path: ./api/app/api/v1
--------------------------------------
# api/app/api/v1/documents.py
"""
Document management API endpoints.
"""
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from typing import List, Optional
from datetime import datetime, date, timedelta

from database import get_db
from models.user import User
from models.volunteer import Volunteer
from models.document import (
    PolicyDocument,
    ElectronicSignature,
    VolunteerDocument,
    DocumentAccessLog
)
from api.deps import get_current_user
from schemas.document import (
    PolicyDocumentCreate,
    PolicyDocumentUpdate,
    PolicyDocumentResponse,
    ElectronicSignatureCreate,
    ElectronicSignatureResponse,
    VolunteerDocumentCreate,
    VolunteerDocumentUpdate,
    VolunteerDocumentResponse,
    DocumentUploadRequest,
    DocumentUploadResponse,
    ExpiringDocumentReport,
    SignatureLogResponse,
    DocumentAccessLogCreate
)
from services.s3_storage import s3_storage

router = APIRouter()


# =============== Policy Documents ===============

@router.get("/policies", response_model=List[PolicyDocumentResponse])
def list_policy_documents(
    active_only: bool = True,
    requires_signature: Optional[bool] = None,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List organizational policy documents."""
    query = db.query(PolicyDocument).filter(
        PolicyDocument.tenant_id == current_user.tenant_id
    )
    
    if active_only:
        query = query.filter(PolicyDocument.is_active == True)
    
    if requires_signature is not None:
        query = query.filter(PolicyDocument.requires_signature == requires_signature)
    
    policies = query.order_by(PolicyDocument.created_at.desc()).offset(skip).limit(limit).all()
    
    return [
        PolicyDocumentResponse(
            **policy.__dict__,
            is_expired=policy.is_expired
        )
        for policy in policies
    ]


@router.post("/policies", response_model=PolicyDocumentResponse, status_code=status.HTTP_201_CREATED)
def create_policy_document(
    policy_data: PolicyDocumentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a new policy document (admin only)."""
    # Check permissions
    if current_user.role not in ["system_admin", "org_admin"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions to create policy documents"
        )
    
    # Create policy
    policy = PolicyDocument(
        **policy_data.dict(),
        created_by=current_user.id
    )
    
    db.add(policy)
    db.commit()
    db.refresh(policy)
    
    return PolicyDocumentResponse(
        **policy.__dict__,
        is_expired=policy.is_expired
    )


@router.get("/policies/{policy_id}", response_model=PolicyDocumentResponse)
def get_policy_document(
    policy_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get a specific policy document."""
    policy = db.query(PolicyDocument).filter(
        PolicyDocument.id == policy_id,
        PolicyDocument.tenant_id == current_user.tenant_id
    ).first()
    
    if not policy:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Policy document not found"
        )
    
    # Log access
    log_document_access(
        db=db,
        document_id=policy_id,
        document_type="policy_document",
        action="view",
        user_id=current_user.id
    )
    
    return PolicyDocumentResponse(
        **policy.__dict__,
        is_expired=policy.is_expired
    )


# =============== Electronic Signatures ===============

@router.post("/sign", response_model=ElectronicSignatureResponse, status_code=status.HTTP_201_CREATED)
def sign_document(
    signature_data: ElectronicSignatureCreate,
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create an electronic signature for a document.
    Captures IP, user agent, and timestamp for non-repudiation.
    """
    # Get volunteer record if current user is a volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    # Create signature
    signature = ElectronicSignature(
        volunteer_id=volunteer.id if volunteer else None,
        user_id=current_user.id if not volunteer else None,
        policy_document_id=signature_data.policy_document_id,
        custom_document_id=signature_data.custom_document_id,
        signature_data=signature_data.signature_data,
        signature_method=signature_data.signature_method,
        ip_address=request.client.host,
        user_agent=request.headers.get("user-agent"),
        geolocation=signature_data.geolocation,
        consent_text=signature_data.consent_text,
        acknowledged_terms=signature_data.acknowledged_terms,
        timestamp=datetime.utcnow()
    )
    
    db.add(signature)
    db.commit()
    db.refresh(signature)
    
    # Log action
    log_document_access(
        db=db,
        document_id=signature_data.policy_document_id or signature_data.custom_document_id,
        document_type="policy_document" if signature_data.policy_document_id else "volunteer_document",
        action="sign",
        user_id=current_user.id,
        volunteer_id=volunteer.id if volunteer else None
    )
    
    return signature


@router.get("/policies/{policy_id}/signatures", response_model=SignatureLogResponse)
def get_policy_signatures(
    policy_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all signatures for a policy document (admin only)."""
    if current_user.role not in ["system_admin", "org_admin", "coordinator"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    
    policy = db.query(PolicyDocument).filter(
        PolicyDocument.id == policy_id,
        PolicyDocument.tenant_id == current_user.tenant_id
    ).first()
    
    if not policy:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Policy not found"
        )
    
    # Get all signatures
    signatures = db.query(ElectronicSignature).filter(
        ElectronicSignature.policy_document_id == policy_id
    ).all()
    
    # Find volunteers who haven't signed
    signed_volunteer_ids = {s.volunteer_id for s in signatures if s.volunteer_id}
    all_volunteers = db.query(Volunteer).filter(
        Volunteer.tenant_id == current_user.tenant_id,
        Volunteer.application_status == 'approved'
    ).all()
    
    unsigned_volunteers = [
        {"id": v.id, "name": v.full_name, "email": v.email}
        for v in all_volunteers
        if v.id not in signed_volunteer_ids
    ]
    
    return SignatureLogResponse(
        document_id=policy_id,
        document_title=policy.title,
        signatures=signatures,
        unsigned_volunteers=unsigned_volunteers
    )


# =============== Volunteer Documents ===============

@router.post("/upload-request", response_model=DocumentUploadResponse)
def request_document_upload(
    upload_request: DocumentUploadRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Request a presigned URL for uploading a document to S3.
    Creates the database record and returns upload URL.
    """
    # Verify volunteer access
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == upload_request.volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Check if user has permission to upload for this volunteer
    if current_user.role == 'volunteer':
        # Volunteers can only upload for themselves
        if volunteer.email != current_user.email:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Cannot upload documents for other volunteers"
            )
    
    # Generate S3 presigned URL
    try:
        upload_url, s3_key = s3_storage.generate_upload_url(
            file_name=upload_request.file_name,
            file_type=upload_request.file_type,
            tenant_id=current_user.tenant_id,
            document_type=upload_request.document_type,
            expires_in=3600  # 1 hour
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate upload URL: {str(e)}"
        )
    
    # Create document record
    document = VolunteerDocument(
        volunteer_id=upload_request.volunteer_id,
        tenant_id=current_user.tenant_id,
        document_type=upload_request.document_type,
        title=upload_request.file_name,
        file_url=f"s3://{s3_storage.bucket_name}/{s3_key}",
        file_name=upload_request.file_name,
        file_size_bytes=upload_request.file_size_bytes,
        file_type=upload_request.file_type,
        uploaded_by=current_user.id,
        verification_status='pending'
    )
    
    db.add(document)
    db.commit()
    db.refresh(document)
    
    return DocumentUploadResponse(
        upload_url=upload_url,
        document_id=document.id,
        expires_in=3600
    )


@router.get("/volunteers/{volunteer_id}/documents", response_model=List[VolunteerDocumentResponse])
def list_volunteer_documents(
    volunteer_id: int,
    document_type: Optional[str] = None,
    include_expired: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all documents for a volunteer."""
    # Verify access
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    query = db.query(VolunteerDocument).filter(
        VolunteerDocument.volunteer_id == volunteer_id
    )
    
    if document_type:
        query = query.filter(VolunteerDocument.document_type == document_type)
    
    if not include_expired:
        query = query.filter(
            or_(
                VolunteerDocument.expires == False,
                VolunteerDocument.expiration_date >= date.today()
            )
        )
    
    documents = query.order_by(VolunteerDocument.uploaded_at.desc()).all()
    
    return [
        VolunteerDocumentResponse(
            **doc.__dict__,
            is_expired=doc.is_expired,
            days_until_expiration=doc.days_until_expiration
        )
        for doc in documents
    ]


@router.patch("/documents/{document_id}/verify", response_model=VolunteerDocumentResponse)
def verify_document(
    document_id: int,
    verification: VolunteerDocumentUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Verify or reject a volunteer document (coordinator only)."""
    if current_user.role not in ["system_admin", "org_admin", "coordinator"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    
    document = db.query(VolunteerDocument).filter(
        VolunteerDocument.id == document_id,
        VolunteerDocument.tenant_id == current_user.tenant_id
    ).first()
    
    if not document:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found"
        )
    
    # Update verification status
    if verification.verification_status:
        document.verification_status = verification.verification_status
        document.verified_by = current_user.id
        document.verified_at = datetime.utcnow()
    
    if verification.rejection_reason:
        document.rejection_reason = verification.rejection_reason
    
    db.commit()
    db.refresh(document)
    
    return VolunteerDocumentResponse(
        **document.__dict__,
        is_expired=document.is_expired,
        days_until_expiration=document.days_until_expiration
    )


@router.get("/expiring", response_model=List[ExpiringDocumentReport])
def get_expiring_documents(
    days: int = 30,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get report of documents expiring within X days."""
    cutoff_date = date.today() + timedelta(days=days)
    
    documents = db.query(
        VolunteerDocument,
        Volunteer
    ).join(
        Volunteer, VolunteerDocument.volunteer_id == Volunteer.id
    ).filter(
        Volunteer.tenant_id == current_user.tenant_id,
        VolunteerDocument.expires == True,
        VolunteerDocument.expiration_date.isnot(None),
        VolunteerDocument.expiration_date <= cutoff_date,
        VolunteerDocument.expiration_date >= date.today()
    ).order_by(
        VolunteerDocument.expiration_date
    ).all()
    
    results = []
    for doc, volunteer in documents:
        days_remaining = (doc.expiration_date - date.today()).days
        results.append(ExpiringDocumentReport(
            volunteer_id=volunteer.id,
            volunteer_name=volunteer.full_name,
            document_type=doc.document_type,
            document_title=doc.title,
            expiration_date=doc.expiration_date,
            days_until_expiration=days_remaining
        ))
    
    return results


# =============== Helper Functions ===============

def log_document_access(
    db: Session,
    document_id: int,
    document_type: str,
    action: str,
    user_id: Optional[int] = None,
    volunteer_id: Optional[int] = None,
    meta_data: Optional[dict] = None
):
    """Log document access for audit trail."""
    log_entry = DocumentAccessLog(
        document_id=document_id,
        document_type=document_type,
        action=action,
        user_id=user_id,
        volunteer_id=volunteer_id,
        meta_data=meta_data
    )
    db.add(log_entry)
    db.commit()
======================================

======================================
File: integrations.py
Path: ./api/app/api/v1
--------------------------------------
"""Integration endpoints for external systems."""
from fastapi import APIRouter, Depends
from models.user import User
from api.deps import get_current_user
from services.train import train_service

router = APIRouter()

@router.get("/train/status")
async def get_train_status(current_user: User = Depends(get_current_user)):
    """
    Get TRAIN integration status.
    Placeholder for Phase 1.
    """
    # TODO: Implement actual TRAIN API integration
    return {
        "status": "placeholder",
        "message": "TRAIN integration will be implemented in Phase 2",
        "api_url": "https://api.train.org/v1",
        "last_sync": None,
        "features": {
            "daily_sync": False,
            "course_mapping": False,
            "expiration_tracking": False
        }
    }

@router.post("/train/sync/{volunteer_id}")
async def sync_volunteer_training(
    volunteer_id: int,
    current_user: User = Depends(get_current_user)
):
    """
    Manually trigger TRAIN sync for a volunteer.
    Placeholder for Phase 1.
    """
    # TODO: Implement actual sync logic
    records = await train_service.sync_volunteer_training("volunteer@example.com")
    return {
        "message": "Sync triggered (placeholder)",
        "volunteer_id": volunteer_id,
        "records_found": len(records),
        "sample_records": records
    }
======================================

======================================
File: events.py
Path: ./api/app/api/v1
--------------------------------------
"""Event management endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func
from typing import List
from database import get_db
from models.user import User
from models.event import Event, EventAssignment, AssignmentStatus
from api.deps import get_current_user
from schemas.event import (
    EventResponse, 
    EventSimpleResponse, 
    EventListResponse,
    EventCreate,
    EventUpdate
)

router = APIRouter()

@router.get("/", response_model=List[EventSimpleResponse])
def list_events(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    List events for the current tenant.
    Returns a simplified structure for frontend compatibility.
    """
    # Query events for current tenant
    events = db.query(Event).filter(
        Event.tenant_id == current_user.tenant_id,
        Event.visible_to_volunteers == True  # Only visible events
    ).offset(skip).limit(limit).all()
    
    # Transform to match frontend expectations
    result = []
    for event in events:
        # Count registered volunteers for this event
        registered_count = db.query(func.count(EventAssignment.id)).filter(
            EventAssignment.event_id == event.id,
            EventAssignment.status.in_([
                AssignmentStatus.CONFIRMED,
                AssignmentStatus.PENDING
            ])
        ).scalar() or 0
        
        # Calculate max volunteers from shifts
        max_volunteers = 0
        if event.shifts:
            max_volunteers = sum(shift.max_volunteers or 0 for shift in event.shifts) if event.shifts else 0
        
        result.append(EventSimpleResponse(
            id=str(event.id),
            tenant_id=str(event.tenant_id),
            title=event.name,  # Map 'name' to 'title'
            description=event.volunteer_description or event.staff_description,
            event_date=event.start_date.isoformat() if event.start_date else "",
            location=event.location,
            max_volunteers=max_volunteers or 50,  # Default if no shifts
            registered_volunteers=registered_count,
            created_by=str(event.created_by) if event.created_by else "1"
        ))
    
    return result

@router.get("/detailed", response_model=EventListResponse)
def list_events_detailed(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    List events with full details.
    Uses proper response schema with all fields.
    """
    query = db.query(Event).filter(Event.tenant_id == current_user.tenant_id)
    
    total = query.count()
    events = query.offset(skip).limit(limit).all()
    
    # Convert to response schema
    event_responses = []
    for event in events:
        # Count volunteers
        registered = db.query(func.count(EventAssignment.id)).filter(
            EventAssignment.event_id == event.id,
            EventAssignment.status == 'confirmed'  # Changed from enum
        ).scalar() or 0
        
        # Calculate max volunteers from shifts - FIXED
        max_volunteers = 0
        if event.shifts:
            max_volunteers = sum(s.max_volunteers or 0 for s in event.shifts)
        if max_volunteers == 0:
            max_volunteers = 50  # Default
        
        # Create response with computed fields
        response_data = {
            **event.__dict__,
            'title': event.name,
            'event_date': event.start_date.isoformat() if event.start_date else None,
            'max_volunteers': max_volunteers,
            'registered_volunteers': registered
        }
        
        event_responses.append(EventResponse(**response_data))
    
    return EventListResponse(total=total, items=event_responses)

@router.get("/{event_id}", response_model=EventSimpleResponse)
def get_event(
    event_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get a single event by ID."""
    event = db.query(Event).filter(
        Event.id == event_id,
        Event.tenant_id == current_user.tenant_id
    ).first()
    
    if not event:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Event not found"
        )
    
    # Count registered volunteers
    registered_count = db.query(func.count(EventAssignment.id)).filter(
        EventAssignment.event_id == event.id,
        EventAssignment.status == AssignmentStatus.CONFIRMED
    ).scalar() or 0
    
    return EventSimpleResponse(
        id=str(event.id),
        tenant_id=str(event.tenant_id),
        title=event.name,
        description=event.volunteer_description or event.staff_description,
        event_date=event.start_date.isoformat() if event.start_date else "",
        location=event.location,
        max_volunteers=sum(s.slots_total for s in event.shifts) if event.shifts else 50,
        registered_volunteers=registered_count,
        created_by=str(event.created_by) if event.created_by else "1"
    )

@router.post("/", response_model=EventSimpleResponse, status_code=status.HTTP_201_CREATED)
def create_event(
    event_data: EventCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a new event."""
    # Ensure user can create events (check permissions)
    if current_user.role.value not in ["system_admin", "org_admin", "coordinator"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions to create events"
        )
    
    # Create event
    event = Event(
        **event_data.dict(exclude={'tenant_id'}),
        tenant_id=current_user.tenant_id,
        created_by=current_user.id,
        status="draft"
    )
    
    db.add(event)
    db.commit()
    db.refresh(event)
    
    return EventSimpleResponse(
        id=str(event.id),
        tenant_id=str(event.tenant_id),
        title=event.name,
        description=event.volunteer_description or event.staff_description,
        event_date=event.start_date.isoformat() if event.start_date else "",
        location=event.location,
        max_volunteers=50,
        registered_volunteers=0,
        created_by=str(event.created_by)
    )======================================

======================================
File: training.py
Path: ./api/app/api/v1
--------------------------------------
# api/app/api/v1/training.py
"""
Training management endpoints.
Handles training records, certifications, and TRAIN integration.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from typing import List
from datetime import date, timedelta

from database import get_db
from models.user import User
from models.volunteer import Volunteer
from models.training import TrainingCourse, VolunteerTraining, Certification
from api.deps import get_current_user
from schemas.training import (
    TrainingCourseResponse,
    VolunteerTrainingCreate,
    VolunteerTrainingResponse,
    CertificationCreate,
    CertificationUpdate,
    CertificationResponse,
    TrainingStatusSummary,
    ExpiringTrainingReport,
    TRAINSyncRequest,
    TRAINSyncResponse
)
from services.train import train_service

router = APIRouter()


# =============== Training Courses ===============

@router.get("/courses", response_model=List[TrainingCourseResponse])
def list_training_courses(
    skip: int = 0,
    limit: int = 100,
    category: str = None,
    required_only: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all training courses for current tenant."""
    query = db.query(TrainingCourse).filter(
        TrainingCourse.tenant_id == current_user.tenant_id
    )
    
    if category:
        query = query.filter(TrainingCourse.category == category)
    if required_only:
        query = query.filter(TrainingCourse.is_required == True)
    
    courses = query.offset(skip).limit(limit).all()
    return courses


@router.get("/courses/{course_id}", response_model=TrainingCourseResponse)
def get_training_course(
    course_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get training course by ID."""
    course = db.query(TrainingCourse).filter(
        TrainingCourse.id == course_id,
        TrainingCourse.tenant_id == current_user.tenant_id
    ).first()
    
    if not course:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training course not found"
        )
    
    return course


# =============== Volunteer Training Records ===============

@router.get("/volunteers/{volunteer_id}/training", response_model=List[VolunteerTrainingResponse])
def get_volunteer_training(
    volunteer_id: int,
    include_expired: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all training records for a volunteer."""
    # Verify volunteer exists and belongs to tenant
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    query = db.query(VolunteerTraining).filter(
        VolunteerTraining.volunteer_id == volunteer_id
    )
    
    if not include_expired:
        query = query.filter(
            or_(
                VolunteerTraining.expiration_date.is_(None),
                VolunteerTraining.expiration_date >= date.today()
            )
        )
    
    trainings = query.all()
    
    # Enhance with course details
    result = []
    for training in trainings:
        training_dict = {
            **training.__dict__,
            'course_name': training.course.name,
            'course_provider': training.course.provider,
            'course_category': training.course.category,
            'is_expired': training.is_expired
        }
        result.append(VolunteerTrainingResponse(**training_dict))
    
    return result


@router.post("/volunteers/{volunteer_id}/training", response_model=VolunteerTrainingResponse, status_code=status.HTTP_201_CREATED)
def add_training_record(
    volunteer_id: int,
    training_data: VolunteerTrainingCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Add a training record for a volunteer (manual entry)."""
    # Verify volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Verify course exists
    course = db.query(TrainingCourse).filter(
        TrainingCourse.id == training_data.course_id
    ).first()
    
    if not course:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training course not found"
        )
    
    # Create training record
    training = VolunteerTraining(**training_data.dict())
    training.synced_from_train = False
    training.status = 'active'
    
    db.add(training)
    db.commit()
    db.refresh(training)
    
    return VolunteerTrainingResponse(
        **training.__dict__,
        course_name=course.name,
        course_provider=course.provider,
        course_category=course.category,
        is_expired=training.is_expired
    )


@router.get("/volunteers/{volunteer_id}/training-status", response_model=TrainingStatusSummary)
def get_training_status(
    volunteer_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get training compliance status for a volunteer."""
    # Verify volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Get all required courses
    required_courses = db.query(TrainingCourse).filter(
        TrainingCourse.tenant_id == current_user.tenant_id,
        TrainingCourse.is_required == True
    ).all()
    
    # Get volunteer's training records
    trainings = db.query(VolunteerTraining).filter(
        VolunteerTraining.volunteer_id == volunteer_id
    ).all()
    
    # Calculate statistics
    completed_course_ids = {t.course_id for t in trainings if not t.is_expired}
    expired_count = sum(1 for t in trainings if t.is_expired)
    
    # Expiring soon (within 90 days)
    expiring_soon = sum(
        1 for t in trainings
        if t.expiration_date and 
        not t.is_expired and
        t.expiration_date <= date.today() + timedelta(days=90)
    )
    
    # Missing required courses
    missing_required = [
        course.name 
        for course in required_courses 
        if course.id not in completed_course_ids
    ]
    
    # Compliance percentage
    if required_courses:
        compliance = (len(completed_course_ids) / len(required_courses)) * 100
    else:
        compliance = 100.0
    
    return TrainingStatusSummary(
        volunteer_id=volunteer_id,
        total_courses=len(trainings),
        completed_courses=len(completed_course_ids),
        expired_courses=expired_count,
        expiring_soon=expiring_soon,
        compliance_percentage=round(compliance, 2),
        missing_required=missing_required
    )


# =============== Certifications ===============

@router.get("/volunteers/{volunteer_id}/certifications", response_model=List[CertificationResponse])
def get_volunteer_certifications(
    volunteer_id: int,
    include_expired: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all certifications for a volunteer."""
    # Verify volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    query = db.query(Certification).filter(
        Certification.volunteer_id == volunteer_id
    )
    
    if not include_expired:
        query = query.filter(
            or_(
                Certification.expiration_date.is_(None),
                Certification.expiration_date >= date.today()
            )
        )
    
    certs = query.all()
    
    # Enhance with computed properties
    result = []
    for cert in certs:
        cert_dict = {
            **cert.__dict__,
            'is_expired': cert.is_expired,
            'days_until_expiration': cert.days_until_expiration
        }
        result.append(CertificationResponse(**cert_dict))
    
    return result


@router.post("/volunteers/{volunteer_id}/certifications", response_model=CertificationResponse, status_code=status.HTTP_201_CREATED)
def add_certification(
    volunteer_id: int,
    cert_data: CertificationCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Add a certification for a volunteer."""
    # Verify volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Create certification
    cert = Certification(**cert_data.dict())
    cert.verification_status = 'pending'
    cert.verified_by = current_user.id
    
    db.add(cert)
    db.commit()
    db.refresh(cert)
    
    return CertificationResponse(
        **cert.__dict__,
        is_expired=cert.is_expired,
        days_until_expiration=cert.days_until_expiration
    )


@router.patch("/certifications/{cert_id}", response_model=CertificationResponse)
def update_certification(
    cert_id: int,
    cert_data: CertificationUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update a certification (e.g., verify, update expiration)."""
    cert = db.query(Certification).filter(Certification.id == cert_id).first()
    
    if not cert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Certification not found"
        )
    
    # Update fields
    for field, value in cert_data.dict(exclude_unset=True).items():
        setattr(cert, field, value)
    
    if cert_data.verification_status:
        cert.verification_date = date.today()
        cert.verified_by = current_user.id
    
    db.commit()
    db.refresh(cert)
    
    return CertificationResponse(
        **cert.__dict__,
        is_expired=cert.is_expired,
        days_until_expiration=cert.days_until_expiration
    )


# =============== Reports ===============

@router.get("/reports/expiring", response_model=List[ExpiringTrainingReport])
def get_expiring_training_report(
    days: int = 90,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get report of training expiring within X days."""
    cutoff_date = date.today() + timedelta(days=days)
    
    # Query expiring training
    trainings = db.query(
        VolunteerTraining,
        Volunteer,
        TrainingCourse
    ).join(
        Volunteer, VolunteerTraining.volunteer_id == Volunteer.id
    ).join(
        TrainingCourse, VolunteerTraining.course_id == TrainingCourse.id
    ).filter(
        Volunteer.tenant_id == current_user.tenant_id,
        VolunteerTraining.expiration_date.isnot(None),
        VolunteerTraining.expiration_date <= cutoff_date,
        VolunteerTraining.expiration_date >= date.today()
    ).order_by(
        VolunteerTraining.expiration_date
    ).all()
    
    # Format results
    results = []
    for training, volunteer, course in trainings:
        days_remaining = (training.expiration_date - date.today()).days
        results.append(ExpiringTrainingReport(
            volunteer_id=volunteer.id,
            volunteer_name=volunteer.full_name,
            course_name=course.name,
            expiration_date=training.expiration_date,
            days_until_expiration=days_remaining,
            is_required=course.is_required
        ))
    
    return results


# =============== TRAIN Integration ===============

@router.post("/train/sync", response_model=TRAINSyncResponse)
async def sync_from_train(
    sync_request: TRAINSyncRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Sync training records from TRAIN API.
    This is a simulated implementation for Phase 1.
    """
    records_synced = 0
    errors = []
    
    # Determine which volunteers to sync
    if sync_request.volunteer_id:
        volunteers = [db.query(Volunteer).filter(
            Volunteer.id == sync_request.volunteer_id,
            Volunteer.tenant_id == current_user.tenant_id
        ).first()]
        
        if not volunteers[0]:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Volunteer not found"
            )
    else:
        # Sync all volunteers in tenant
        volunteers = db.query(Volunteer).filter(
            Volunteer.tenant_id == current_user.tenant_id,
            Volunteer.application_status == 'approved'
        ).limit(10).all()  # Limit for demo
    
    # Sync each volunteer
    for volunteer in volunteers:
        try:
            # Call TRAIN service (simulated)
            train_records = await train_service.sync_volunteer_training(volunteer.email)
            
            for record in train_records:
                # Find or create course
                course = db.query(TrainingCourse).filter(
                    TrainingCourse.train_course_id == record['train_course_id']
                ).first()
                
                if not course:
                    # Create course from TRAIN data
                    course = TrainingCourse(
                        tenant_id=current_user.tenant_id,
                        train_course_id=record['train_course_id'],
                        name=record['course_name'],
                        course_code=record.get('course_code'),
                        provider=record.get('course_provider'),
                        category=record.get('course_category'),
                        is_required=False
                    )
                    db.add(course)
                    db.flush()
                
                # Check if training record already exists
                existing = db.query(VolunteerTraining).filter(
                    VolunteerTraining.train_completion_id == record['train_completion_id']
                ).first()
                
                if existing and not sync_request.force:
                    continue  # Skip if already exists
                
                # Create or update training record
                if existing:
                    training = existing
                else:
                    training = VolunteerTraining(
                        volunteer_id=volunteer.id,
                        course_id=course.id,
                        train_completion_id=record['train_completion_id']
                    )
                
                training.completion_date = record['completion_date']
                training.expiration_date = record.get('expiration_date')
                training.score = record.get('score')
                training.certificate_url = record.get('certificate_url')
                training.synced_from_train = True
                training.last_sync_date = datetime.utcnow()
                training.status = 'active'
                
                if not existing:
                    db.add(training)
                
                records_synced += 1
            
        except Exception as e:
            errors.append(f"Error syncing {volunteer.email}: {str(e)}")
    
    db.commit()
    
    return TRAINSyncResponse(
        success=len(errors) == 0,
        records_synced=records_synced,
        errors=errors,
        message=f"Synced {records_synced} training records from TRAIN"
    )


@router.get("/train/status")
async def get_train_status(
    current_user: User = Depends(get_current_user)
):
    """
    Get TRAIN integration status.
    Placeholder for Phase 1.
    """
    return {
        "status": "simulated",
        "message": "TRAIN integration is currently simulated. Will be implemented with real API in Phase 2",
        "api_url": "https://api.train.org/v1",
        "last_sync": None,
        "features": {
            "daily_sync": False,
            "course_mapping": True,
            "expiration_tracking": True
        }
    }======================================

======================================
File: __init__.py
Path: ./api/app/api/v1
--------------------------------------
"""API v1 router package."""
======================================

======================================
File: auth.py
Path: ./api/app/api/v1
--------------------------------------
"""
Authentication endpoints.
"""
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from database import get_db
from models.user import User
from schemas.auth import Token, LoginRequest, RefreshTokenRequest
from core.security import (
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token
)
from services.audit import log_action

router = APIRouter()


@router.post("/login", response_model=Token)
def login(
    login_data: LoginRequest,
    db: Session = Depends(get_db)
):
    """
    User login endpoint.
    Returns access and refresh JWT tokens.
    """
    # Find user
    user = db.query(User).filter(User.username == login_data.username).first()
    
    if not user or not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if user.status != "active":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is not active"
        )
    
    # Update last login
    user.last_login = datetime.utcnow()
    db.commit()
    
    # Create tokens
    token_data = {
        "sub": user.id,
        "username": user.username,
        "tenant_id": user.tenant_id,
        "role": user.role.value
    }
    
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)
    
    # Log action
    log_action(
        db=db,
        user_id=user.id,
        tenant_id=user.tenant_id,
        action="auth.login",
        resource_type="user",
        resource_id=user.id,
        description=f"User {user.username} logged in"
    )
    
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    )


@router.post("/refresh", response_model=Token)
def refresh_token(
    refresh_data: RefreshTokenRequest,
    db: Session = Depends(get_db)
):
    """
    Refresh access token using refresh token.
    """
    try:
        payload = decode_token(refresh_data.refresh_token)
        
        if payload.get("type") != "refresh":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token type"
            )
        
        user_id = payload.get("sub")
        user = db.query(User).filter(User.id == user_id).first()
        
        if not user or user.status != "active":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found or inactive"
            )
        
        # Create new tokens
        token_data = {
            "sub": user.id,
            "username": user.username,
            "tenant_id": user.tenant_id,
            "role": user.role.value
        }
        
        access_token = create_access_token(token_data)
        new_refresh_token = create_refresh_token(token_data)
        
        return Token(
            access_token=access_token,
            refresh_token=new_refresh_token,
            token_type="bearer"
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )


@router.post("/logout")
def logout(db: Session = Depends(get_db)):
    """
    Logout endpoint (client should discard tokens).
    """
    # In a production system, you might want to blacklist the token
    # For now, client-side token removal is sufficient
    return {"message": "Successfully logged out"}
======================================

======================================
File: scheduling.py
Path: ./api/app/api/v1
--------------------------------------
"""
Advanced scheduling endpoints for shift management.
Implements section 1.2 from roadmap.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_
from typing import List
from datetime import datetime, date, timedelta
from database import get_db
from models.user import User
from models.volunteer import Volunteer
from models.event import Event, Shift, EventAssignment
from api.deps import get_current_user
from schemas.scheduling import (
    ShiftTemplateCreate, ShiftTemplateResponse,
    WaitlistJoinRequest, WaitlistResponse,
    AvailabilityCreate, AvailabilityUpdate, AvailabilityResponse,
    SwapRequestCreate, SwapRequestResponse,
    ShiftSelfSignupRequest, AvailableShiftResponse,
    BulkShiftCreateRequest, BulkShiftCreateResponse
)

router = APIRouter()


# ======================
# SHIFT TEMPLATES
# ======================

@router.get("/templates", response_model=List[ShiftTemplateResponse])
def list_shift_templates(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all shift templates for current tenant."""
    from models.event import Shift
    
    # Mock response for now - implement actual model later
    return []


@router.post("/templates", response_model=ShiftTemplateResponse, status_code=status.HTTP_201_CREATED)
def create_shift_template(
    template_data: ShiftTemplateCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a new shift template for recurring shifts."""
    # TODO: Implement shift template model
    raise HTTPException(
        status_code=status.HTTP_501_NOT_IMPLEMENTED,
        detail="Shift templates will be implemented in phase 2"
    )


# ======================
# AVAILABLE SHIFTS & SELF-SIGNUP
# ======================

@router.get("/shifts/available", response_model=List[AvailableShiftResponse])
def get_available_shifts(
    start_date: date = None,
    end_date: date = None,
    include_full: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get list of available shifts for self-signup.
    Volunteers can browse and sign up for open shifts.
    """
    # Build query for shifts with self-signup enabled
    query = db.query(Shift).join(Event).filter(
        Event.tenant_id == current_user.tenant_id,
        Shift.allow_self_signup == True,
        Shift.start_time >= datetime.now()
    )
    
    # Filter by date range
    if start_date:
        query = query.filter(Shift.start_time >= datetime.combine(start_date, datetime.min.time()))
    if end_date:
        query = query.filter(Shift.start_time <= datetime.combine(end_date, datetime.max.time()))
    
    shifts = query.all()
    
    # Transform to response format
    available_shifts = []
    for shift in shifts:
        # Count current volunteers
        current_count = db.query(func.count(EventAssignment.id)).filter(
            EventAssignment.shift_id == shift.id,
            EventAssignment.status.in_(['confirmed', 'pending'])
        ).scalar() or 0
        
        # Count waitlist
        waitlist_count = 0  # TODO: Query actual waitlist table
        
        # Calculate available spots
        available_spots = (shift.max_volunteers or 0) - current_count
        
        # Skip full shifts if not requested
        if not include_full and available_spots <= 0:
            continue
        
        available_shifts.append(AvailableShiftResponse(
            id=shift.id,
            event_id=shift.event_id,
            name=shift.name,
            start_time=shift.start_time,
            end_time=shift.end_time,
            location=shift.location,
            max_volunteers=shift.max_volunteers,
            current_volunteers=current_count,
            available_spots=max(0, available_spots),
            waitlist_count=waitlist_count,
            allow_self_signup=shift.allow_self_signup or False,
            enable_waitlist=shift.enable_waitlist or False,
            required_skills=shift.required_skills,
            event_name=shift.event.name,
            event_description=shift.event.volunteer_description
        ))
    
    return available_shifts


@router.post("/shifts/{shift_id}/signup", status_code=status.HTTP_201_CREATED)
def self_signup_for_shift(
    shift_id: int,
    request_data: ShiftSelfSignupRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Self-signup for an available shift.
    Includes conflict detection and capacity checking.
    """
    # Get shift
    shift = db.query(Shift).filter(Shift.id == shift_id).first()
    if not shift:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Shift not found"
        )
    
    # Check if self-signup is allowed
    if not shift.allow_self_signup:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Self-signup is not enabled for this shift"
        )
    
    # Get volunteer record for current user
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer profile not found"
        )
    
    # Check for conflicts (double-booking)
    if shift.conflict_detection:
        conflicts = db.query(EventAssignment).join(Shift).filter(
            EventAssignment.volunteer_id == volunteer.id,
            EventAssignment.status.in_(['confirmed', 'pending']),
            or_(
                and_(
                    Shift.start_time <= shift.start_time,
                    Shift.end_time > shift.start_time
                ),
                and_(
                    Shift.start_time < shift.end_time,
                    Shift.end_time >= shift.end_time
                )
            )
        ).first()
        
        if conflicts:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="You have a conflicting shift assignment during this time"
            )
    
    # Check capacity
    current_count = db.query(func.count(EventAssignment.id)).filter(
        EventAssignment.shift_id == shift_id,
        EventAssignment.status.in_(['confirmed', 'pending'])
    ).scalar() or 0
    
    if shift.max_volunteers and current_count >= shift.max_volunteers:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Shift is full. Consider joining the waitlist."
        )
    
    # Check if already signed up
    existing = db.query(EventAssignment).filter(
        EventAssignment.shift_id == shift_id,
        EventAssignment.volunteer_id == volunteer.id
    ).first()
    
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="You are already signed up for this shift"
        )
    
    # Create assignment
    assignment = EventAssignment(
        event_id=shift.event_id,
        shift_id=shift_id,
        volunteer_id=volunteer.id,
        status='confirmed',
        notes=request_data.notes,
        assigned_at=datetime.utcnow()
    )
    
    db.add(assignment)
    db.commit()
    db.refresh(assignment)
    
    # TODO: Send confirmation email/notification
    
    return {
        "message": "Successfully signed up for shift",
        "assignment_id": assignment.id,
        "shift_name": shift.name,
        "start_time": shift.start_time.isoformat()
    }


# ======================
# WAITLIST MANAGEMENT
# ======================

@router.post("/shifts/{shift_id}/waitlist", response_model=WaitlistResponse, status_code=status.HTTP_201_CREATED)
def join_waitlist(
    shift_id: int,
    request_data: WaitlistJoinRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Join waitlist for a full shift.
    Will be automatically promoted when a spot opens.
    """
    # Get shift
    shift = db.query(Shift).filter(Shift.id == shift_id).first()
    if not shift:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Shift not found"
        )
    
    if not shift.enable_waitlist:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Waitlist is not enabled for this shift"
        )
    
    # Get volunteer
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer profile not found"
        )
    
    # Check if already on waitlist
    # TODO: Query actual waitlist table
    
    # TODO: Create waitlist entry with proper position
    
    return {
        "message": "Added to waitlist",
        "shift_id": shift_id,
        "position": 1  # Calculate actual position
    }


@router.get("/waitlists/mine", response_model=List[WaitlistResponse])
def get_my_waitlists(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all waitlist entries for current volunteer."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        return []
    
    # TODO: Query actual waitlist table
    return []


# ======================
# AVAILABILITY MARKING
# ======================

@router.post("/availability", response_model=AvailabilityResponse, status_code=status.HTTP_201_CREATED)
def mark_availability(
    availability_data: AvailabilityCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Mark availability for date ranges.
    Coordinators can use this to assign volunteers.
    """
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer profile not found"
        )
    
    # TODO: Create availability record in database
    
    return {
        "message": "Availability marked successfully"
    }


@router.get("/availability/mine", response_model=List[AvailabilityResponse])
def get_my_availability(
    start_date: date = None,
    end_date: date = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get availability calendar for current volunteer."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        return []
    
    # TODO: Query availability records
    return []


# ======================
# SHIFT SWAPPING
# ======================

@router.post("/swap-requests", response_model=SwapRequestResponse, status_code=status.HTTP_201_CREATED)
def request_shift_swap(
    swap_data: SwapRequestCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Request to swap a shift with another volunteer.
    Requires coordinator approval.
    """
    # Get original assignment
    assignment = db.query(EventAssignment).filter(
        EventAssignment.id == swap_data.original_assignment_id
    ).first()
    
    if not assignment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Assignment not found"
        )
    
    # Verify ownership
    volunteer = db.query(Volunteer).filter(
        Volunteer.email == current_user.email,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer or assignment.volunteer_id != volunteer.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only request swaps for your own assignments"
        )
    
    # TODO: Create swap request in database
    # TODO: Send notification to target volunteer and coordinator
    
    return {
        "message": "Swap request submitted",
        "assignment_id": assignment.id
    }


@router.get("/swap-requests/pending")
def get_pending_swap_requests(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get pending swap requests (for coordinators)."""
    # TODO: Query swap requests
    return []


@router.patch("/swap-requests/{swap_id}/approve")
def approve_swap_request(
    swap_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Approve a shift swap request (coordinator only)."""
    # TODO: Implement swap approval logic
    # TODO: Swap the assignments
    # TODO: Notify both volunteers
    
    return {"message": "Swap request approved"}


# ======================
# BULK OPERATIONS
# ======================

@router.post("/shifts/bulk-create", response_model=BulkShiftCreateResponse)
def bulk_create_shifts_from_template(
    request_data: BulkShiftCreateRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create multiple shifts from a template.
    Useful for recurring events like weekly vaccine clinics.
    """
    # TODO: Get template
    # TODO: Generate shifts based on recurrence pattern
    # TODO: Create all shifts in database
    
    return BulkShiftCreateResponse(
        created_count=0,
        shifts_created=[],
        message="Bulk shift creation will be implemented in phase 2"
    )======================================

======================================
File: reporting.py
Path: ./api/app/api/v1
--------------------------------------
# api/app/api/v1/reporting.py
"""
Reporting and analytics endpoints.
"""
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_, text
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import io
import pandas as pd
from openpyxl import Workbook

from database import get_db
from models.user import User
from models.volunteer import Volunteer
from models.event import Event
from models.time_tracking import TimeEntry
from models.training import VolunteerTraining, Certification
from models.reporting import SavedReport, ReportExecution, ReportField, ReportWorkflow
from api.deps import get_current_user
from schemas.reporting import (
    SavedReportCreate,
    SavedReportUpdate,
    SavedReportResponse,
    ExecuteReportRequest,
    ReportExecutionResponse,
    ReportResultsResponse,
    WorkflowCreate,
    WorkflowResponse,
    VolunteerHoursReport,
    ImpactDataReport,
    ComplianceReport,
    UnitMetricsReport,
    ExportFormat
)

router = APIRouter()


# ============ Saved Reports ============

@router.get("/reports", response_model=List[SavedReportResponse])
def list_saved_reports(
    report_type: Optional[str] = None,
    include_shared: bool = True,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List saved reports accessible to current user."""
    query = db.query(SavedReport).filter(
        SavedReport.tenant_id == current_user.tenant_id,
        SavedReport.is_active == True
    )
    
    if report_type:
        query = query.filter(SavedReport.report_type == report_type)
    
    # Filter by access
    if include_shared:
        query = query.filter(
            or_(
                SavedReport.created_by == current_user.id,
                SavedReport.is_public == True,
                # TODO: Check shared_with_roles and shared_with_users
            )
        )
    else:
        query = query.filter(SavedReport.created_by == current_user.id)
    
    reports = query.order_by(SavedReport.created_at.desc()).offset(skip).limit(limit).all()
    return reports


@router.post("/reports", response_model=SavedReportResponse, status_code=status.HTTP_201_CREATED)
def create_saved_report(
    report_data: SavedReportCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a new saved report."""
    report = SavedReport(
        tenant_id=current_user.tenant_id,
        **report_data.dict(),
        created_by=current_user.id
    )
    
    db.add(report)
    db.commit()
    db.refresh(report)
    
    return report


@router.get("/reports/{report_id}", response_model=SavedReportResponse)
def get_saved_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get saved report by ID."""
    report = db.query(SavedReport).filter(
        SavedReport.id == report_id,
        SavedReport.tenant_id == current_user.tenant_id
    ).first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # TODO: Check access permissions
    
    return report


@router.patch("/reports/{report_id}", response_model=SavedReportResponse)
def update_saved_report(
    report_id: int,
    report_data: SavedReportUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update saved report."""
    report = db.query(SavedReport).filter(
        SavedReport.id == report_id,
        SavedReport.tenant_id == current_user.tenant_id
    ).first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Only creator can update
    if report.created_by != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only report creator can update"
        )
    
    for field, value in report_data.dict(exclude_unset=True).items():
        setattr(report, field, value)
    
    db.commit()
    db.refresh(report)
    
    return report


@router.delete("/reports/{report_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_saved_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Delete saved report."""
    report = db.query(SavedReport).filter(
        SavedReport.id == report_id,
        SavedReport.tenant_id == current_user.tenant_id,
        SavedReport.created_by == current_user.id
    ).first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    db.delete(report)
    db.commit()


# ============ Report Execution ============

@router.post("/reports/{report_id}/execute")
def execute_report(
    report_id: int,
    request: ExecuteReportRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Execute a report and return results."""
    report = db.query(SavedReport).filter(
        SavedReport.id == report_id,
        SavedReport.tenant_id == current_user.tenant_id
    ).first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    start_time = datetime.utcnow()
    
    try:
        # Build query based on configuration
        results = build_and_execute_query(
            db=db,
            tenant_id=current_user.tenant_id,
            query_config=report.query_config
        )
        
        execution_time = int((datetime.utcnow() - start_time).total_seconds() * 1000)
        
        # Create execution record
        execution = ReportExecution(
            report_id=report_id,
            executed_by=current_user.id,
            execution_time_ms=execution_time,
            row_count=len(results.get('rows', [])),
            file_format=request.export_format,
            status='completed'
        )
        
        db.add(execution)
        
        # Update last generated time
        report.last_generated_at = datetime.utcnow()
        
        db.commit()
        db.refresh(execution)
        
        # If export requested, generate file in background
        if request.export_format != ExportFormat.JSON:
            background_tasks.add_task(
                generate_export_file,
                execution_id=execution.id,
                results=results,
                format=request.export_format,
                db=db
            )
        
        return {
            "execution_id": execution.id,
            "results": results if request.export_format == ExportFormat.JSON else None,
            "status": "completed",
            "execution_time_ms": execution_time
        }
        
    except Exception as e:
        execution = ReportExecution(
            report_id=report_id,
            executed_by=current_user.id,
            status='failed',
            error_message=str(e)
        )
        db.add(execution)
        db.commit()
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Report execution failed: {str(e)}"
        )


# ============ Pre-built Reports ============

@router.get("/reports/volunteer-hours", response_model=List[VolunteerHoursReport])
def get_volunteer_hours_report(
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    volunteer_id: Optional[int] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Volunteer hours report.
    Shows individual and collective hours with filtering.
    """
    query = db.query(
        Volunteer.id,
        Volunteer.first_name,
        Volunteer.last_name,
        func.coalesce(func.sum(TimeEntry.hours_decimal), 0).label('total_hours'),
        func.coalesce(
            func.sum(func.case((TimeEntry.status == 'approved', TimeEntry.hours_decimal), else_=0)), 
            0
        ).label('approved_hours'),
        func.coalesce(
            func.sum(func.case((TimeEntry.status == 'pending', TimeEntry.hours_decimal), else_=0)), 
            0
        ).label('pending_hours'),
        func.count(func.distinct(TimeEntry.event_id)).label('events_attended')
    ).outerjoin(
        TimeEntry, Volunteer.id == TimeEntry.volunteer_id
    ).filter(
        Volunteer.tenant_id == current_user.tenant_id
    )
    
    if volunteer_id:
        query = query.filter(Volunteer.id == volunteer_id)
    
    if start_date:
        query = query.filter(TimeEntry.check_in_time >= start_date)
    if end_date:
        query = query.filter(TimeEntry.check_in_time <= end_date)
    
    query = query.group_by(Volunteer.id, Volunteer.first_name, Volunteer.last_name)
    
    results = query.all()
    
    return [
        VolunteerHoursReport(
            volunteer_id=r.id,
            volunteer_name=f"{r.first_name} {r.last_name}",
            total_hours=float(r.total_hours or 0),
            approved_hours=float(r.approved_hours or 0),
            pending_hours=float(r.pending_hours or 0),
            events_attended=r.events_attended,
            date_range_start=start_date,
            date_range_end=end_date
        )
        for r in results
    ]


@router.get("/reports/compliance", response_model=List[ComplianceReport])
def get_compliance_report(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Compliance report showing training completion and certification status.
    """
    # Get all volunteers with their training status
    volunteers = db.query(Volunteer).filter(
        Volunteer.tenant_id == current_user.tenant_id,
        Volunteer.application_status == 'approved'
    ).all()
    
    # Get required trainings (would come from configuration)
    required_trainings = ['ICS 100', 'CPR', 'HIPAA Training']
    
    results = []
    for volunteer in volunteers:
        # Get completed trainings
        completed = db.query(VolunteerTraining).join(
            VolunteerTraining.course
        ).filter(
            VolunteerTraining.volunteer_id == volunteer.id,
            VolunteerTraining.status == 'active'
        ).all()
        
        completed_names = [t.course.name for t in completed if t.course]
        missing = [t for t in required_trainings if t not in completed_names]
        
        # Get expired certifications
        expired_certs = db.query(Certification).filter(
            Certification.volunteer_id == volunteer.id,
            Certification.expiration_date < date.today()
        ).all()
        
        compliance_pct = ((len(completed_names) / len(required_trainings)) * 100) if required_trainings else 100
        
        results.append(ComplianceReport(
            volunteer_id=volunteer.id,
            volunteer_name=volunteer.full_name,
            required_trainings=required_trainings,
            completed_trainings=completed_names,
            missing_trainings=missing,
            expired_certifications=[c.certification_type for c in expired_certs],
            compliance_percentage=round(compliance_pct, 2)
        ))
    
    return results


@router.get("/reports/unit-metrics", response_model=UnitMetricsReport)
def get_unit_metrics_report(
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Unit-level metrics report.
    """
    if not start_date:
        start_date = date.today() - timedelta(days=30)
    if not end_date:
        end_date = date.today()
    
    # Total volunteers
    total_volunteers = db.query(func.count(Volunteer.id)).filter(
        Volunteer.tenant_id == current_user.tenant_id
    ).scalar()
    
    # Active volunteers (volunteered in period)
    active_volunteers = db.query(func.count(func.distinct(TimeEntry.volunteer_id))).filter(
        TimeEntry.tenant_id == current_user.tenant_id,
        TimeEntry.check_in_time >= start_date,
        TimeEntry.check_in_time <= end_date
    ).scalar()
    
    # Total events in period
    total_events = db.query(func.count(Event.id)).filter(
        Event.tenant_id == current_user.tenant_id,
        Event.start_date >= start_date,
        Event.start_date <= end_date
    ).scalar()
    
    # Total hours
    total_hours = db.query(func.sum(TimeEntry.hours_decimal)).filter(
        TimeEntry.tenant_id == current_user.tenant_id,
        TimeEntry.status == 'approved',
        TimeEntry.check_in_time >= start_date,
        TimeEntry.check_in_time <= end_date
    ).scalar() or 0
    
    # Average hours per volunteer
    avg_hours = total_hours / total_volunteers if total_volunteers > 0 else 0
    
    # Retention rate (volunteers who volunteered in both periods)
    # Simplified calculation
    retention_rate = (active_volunteers / total_volunteers * 100) if total_volunteers > 0 else 0
    
    return UnitMetricsReport(
        unit_name="Main Unit",  # Would come from tenant/user
        total_volunteers=total_volunteers,
        active_volunteers=active_volunteers,
        total_events=total_events,
        total_hours_served=float(total_hours),
        average_hours_per_volunteer=round(avg_hours, 2),
        retention_rate=round(retention_rate, 2),
        period_start=datetime.combine(start_date, datetime.min.time()),
        period_end=datetime.combine(end_date, datetime.max.time())
    )


# ============ Export Functions ============

def generate_export_file(
    execution_id: int,
    results: Dict[str, Any],
    format: ExportFormat,
    db: Session
):
    """Generate export file in background."""
    try:
        if format == ExportFormat.EXCEL:
            file_content = generate_excel(results)
            file_ext = 'xlsx'
        elif format == ExportFormat.CSV:
            file_content = generate_csv(results)
            file_ext = 'csv'
        elif format == ExportFormat.PDF:
            file_content = generate_pdf(results)
            file_ext = 'pdf'
        else:
            raise ValueError(f"Unsupported format: {format}")
        
        # Upload to S3 (implement S3 upload)
        # file_url = upload_to_s3(file_content, f"reports/{execution_id}.{file_ext}")
        file_url = f"/exports/report_{execution_id}.{file_ext}"  # Placeholder
        
        # Update execution record
        execution = db.query(ReportExecution).filter(
            ReportExecution.id == execution_id
        ).first()
        
        if execution:
            execution.file_url = file_url
            execution.file_size_bytes = len(file_content)
            execution.status = 'completed'
            db.commit()
            
    except Exception as e:
        execution = db.query(ReportExecution).filter(
            ReportExecution.id == execution_id
        ).first()
        if execution:
            execution.status = 'failed'
            execution.error_message = str(e)
            db.commit()


def generate_excel(results: Dict[str, Any]) -> bytes:
    """Generate Excel file from results."""
    df = pd.DataFrame(results['rows'])
    
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, sheet_name='Report', index=False)
    
    return output.getvalue()


def generate_csv(results: Dict[str, Any]) -> bytes:
    """Generate CSV file from results."""
    df = pd.DataFrame(results['rows'])
    return df.to_csv(index=False).encode('utf-8')


def generate_pdf(results: Dict[str, Any]) -> bytes:
    """Generate PDF file from results."""
    # Implement PDF generation using reportlab or similar
    # For now, return placeholder
    return b"PDF generation not yet implemented"


def build_and_execute_query(
    db: Session,
    tenant_id: int,
    query_config: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Build and execute a query based on configuration.
    This is a simplified implementation - production would be more robust.
    """
    entity_type = query_config.get('entity_type')
    fields = query_config.get('fields', [])
    filters = query_config.get('filters', [])
    
    # Map entity types to models
    entity_map = {
        'volunteer': Volunteer,
        'event': Event,
        'time_entry': TimeEntry,
        'training': VolunteerTraining
    }
    
    model = entity_map.get(entity_type)
    if not model:
        raise ValueError(f"Unknown entity type: {entity_type}")
    
    # Build query
    query = db.query(model).filter(model.tenant_id == tenant_id)
    
    # Apply filters (simplified)
    for f in filters:
        field_name = f.get('field')
        operator = f.get('operator')
        value = f.get('value')
        
        if hasattr(model, field_name):
            field = getattr(model, field_name)
            
            if operator == 'eq':
                query = query.filter(field == value)
            elif operator == 'ne':
                query = query.filter(field != value)
            elif operator == 'gt':
                query = query.filter(field > value)
            elif operator == 'lt':
                query = query.filter(field < value)
            # Add more operators as needed
    
    # Execute and format results
    results = query.all()
    
    rows = []
    for result in results:
        row = {}
        for field in fields:
            if hasattr(result, field):
                value = getattr(result, field)
                # Convert datetime to string
                if isinstance(value, datetime):
                    value = value.isoformat()
                row[field] = value
        rows.append(row)
    
    return {
        'columns': fields,
        'rows': rows,
        'total_count': len(rows)
    }


# ============ Workflow Automation ============

@router.post("/workflows", response_model=WorkflowResponse, status_code=status.HTTP_201_CREATED)
def create_workflow(
    workflow_data: WorkflowCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create workflow automation."""
    workflow = ReportWorkflow(
        tenant_id=current_user.tenant_id,
        **workflow_data.dict(),
        created_by=current_user.id
    )
    
    db.add(workflow)
    db.commit()
    db.refresh(workflow)
    
    return workflow


@router.get("/workflows", response_model=List[WorkflowResponse])
def list_workflows(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List workflows."""
    workflows = db.query(ReportWorkflow).filter(
        ReportWorkflow.tenant_id == current_user.tenant_id,
        ReportWorkflow.is_active == True
    ).all()
    
    return workflows


# ============ Report Fields (for Ad Hoc Builder) ============

@router.get("/fields")
def get_available_fields(
    entity_type: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get available fields for report builder."""
    query = db.query(ReportField)
    
    if entity_type:
        query = query.filter(ReportField.entity_type == entity_type)
    
    fields = query.all()
    return fields
======================================

======================================
File: reports.py
Path: ./api/app/api/v1
--------------------------------------
"""Reporting endpoints (stub for Phase 1)."""
from fastapi import APIRouter, Depends
from models.user import User
from api.deps import get_current_user

router = APIRouter()

@router.get("/alert-response-rate")
def get_alert_response_report(current_user: User = Depends(get_current_user)):
    """Alert response rate report (stub)."""
    return {"message": "Alert response rate report - coming soon"}

# TODO: Add reporting endpoints
======================================

======================================
File: volunteers.py
Path: ./api/app/api/v1
--------------------------------------
"""Volunteer management endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime
from database import get_db
from models.user import User
from models.volunteer import Volunteer, VolunteerStatus
from api.deps import get_current_user
from schemas.volunteer import (
    VolunteerListResponse, 
    VolunteerStatsResponse,
    VolunteerResponse,
    PublicVolunteerRegistration,
    RegistrationSuccessResponse
)
from core.security import get_password_hash

router = APIRouter()


@router.post("/register", response_model=RegistrationSuccessResponse, status_code=status.HTTP_201_CREATED)
def public_volunteer_registration(
    registration_data: PublicVolunteerRegistration,
    db: Session = Depends(get_db)
):
    """
    PUBLIC endpoint for volunteer self-registration.
    No authentication required - this is the entry point for new volunteers.
    
    Creates a volunteer account with 'pending' status that requires coordinator approval.
    """
    # Check if email already exists
    existing = db.query(Volunteer).filter(Volunteer.email == registration_data.email).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A volunteer with this email already exists"
        )
    
    # Create username from email
    username = registration_data.email.lower().strip()
    
    # Check if username exists
    existing_username = db.query(Volunteer).filter(Volunteer.username == username).first()
    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="This username is already taken"
        )
    
    # Hash password
    hashed_password = get_password_hash(registration_data.password)
    
    # Create volunteer with PENDING status
    volunteer_data = registration_data.dict(exclude={'password'})
    volunteer = Volunteer(
        **volunteer_data,
        username=username,
        hashed_password=hashed_password,
        application_status='pending',  # Requires coordinator approval
        account_status='active',
        application_date=datetime.utcnow()
    )
    
    db.add(volunteer)
    db.commit()
    db.refresh(volunteer)
    
    # TODO: Send welcome email to volunteer
    # TODO: Send notification to unit coordinator
    
    return RegistrationSuccessResponse(
        message="Registration successful! Your application is pending coordinator approval.",
        volunteer_id=volunteer.id,
        email=volunteer.email,
        status=volunteer.application_status
    )


@router.get("/", response_model=VolunteerListResponse)
def list_volunteers(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List volunteers in current tenant."""
    volunteers = db.query(Volunteer).filter(
        Volunteer.tenant_id == current_user.tenant_id
    ).offset(skip).limit(limit).all()
    total = db.query(Volunteer).filter(Volunteer.tenant_id == current_user.tenant_id).count()
    return VolunteerListResponse(total=total, items=volunteers)


@router.get("/stats", response_model=VolunteerStatsResponse)
def get_volunteer_stats(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get volunteer statistics for dashboard."""
    base_query = db.query(Volunteer).filter(Volunteer.tenant_id == current_user.tenant_id)
    
    total = base_query.count()
    approved = base_query.filter(Volunteer.application_status == VolunteerStatus.APPROVED).count()
    pending = base_query.filter(Volunteer.application_status == VolunteerStatus.PENDING).count()
    incomplete = base_query.filter(Volunteer.application_status == VolunteerStatus.INCOMPLETE).count()
    working = base_query.filter(Volunteer.application_status == VolunteerStatus.WORKING).count()
    
    return VolunteerStatsResponse(
        total_volunteers=total,
        approved_volunteers=approved,
        pending_applications=pending,
        incomplete_applications=incomplete,
        working_volunteers=working
    )


@router.get("/{volunteer_id}", response_model=VolunteerResponse)
def get_volunteer(
    volunteer_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get a single volunteer by ID."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    return volunteer


@router.patch("/{volunteer_id}/approve", response_model=VolunteerResponse)
def approve_volunteer(
    volunteer_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Approve a pending volunteer application."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    volunteer.application_status = 'approved'
    volunteer.approval_date = datetime.utcnow()
    volunteer.approved_by = current_user.id
    
    db.commit()
    db.refresh(volunteer)
    
    # TODO: Send approval email to volunteer
    
    return volunteer


@router.delete("/{volunteer_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_volunteer(
    volunteer_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Delete a volunteer."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    db.delete(volunteer)
    db.commit()
    
    return None======================================

======================================
File: users.py
Path: ./api/app/api/v1
--------------------------------------
"""User management endpoints (stub for Phase 1)."""
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from database import get_db
from models.user import User
from api.deps import get_current_user
from schemas.user import UserListResponse, UserResponse

router = APIRouter()

# Add this endpoint to the users router
@router.get("/me", response_model=UserResponse)
def get_current_user_profile(
    current_user: User = Depends(get_current_user)
):
    """Get current user profile."""
    return current_user


@router.get("/", response_model=UserListResponse)
def list_users(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List users in current tenant."""
    users = db.query(User).filter(User.tenant_id == current_user.tenant_id).offset(skip).limit(limit).all()
    total = db.query(User).filter(User.tenant_id == current_user.tenant_id).count()
    return UserListResponse(total=total, items=users)

# TODO: Add CRUD endpoints for users

from fastapi import Request
from api.v1 import users

# Add a debug endpoint to the users router
@users.router.get("/debug-headers")
async def debug_headers(request: Request):
    headers = dict(request.headers)
    return {
        "headers": headers,
        "has_authorization": "authorization" in headers,
        "authorization_value": headers.get("authorization", "NOT FOUND")
    }
======================================

======================================
File: tenants.py
Path: ./api/app/api/v1
--------------------------------------
"""
Tenant management endpoints for SaaS administration.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from database import get_db
from models.tenant import Tenant
from models.user import User, UserRole
from schemas.tenant import TenantCreate, TenantUpdate, TenantResponse, TenantListResponse
from api.deps import get_current_user, require_role
from services.audit import log_action

router = APIRouter()


@router.get("/", response_model=TenantListResponse)
def list_tenants(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role([UserRole.SYSTEM_ADMIN]))
):
    """
    List all tenants (System Admin only).
    """
    tenants = db.query(Tenant).offset(skip).limit(limit).all()
    total = db.query(Tenant).count()
    
    return TenantListResponse(total=total, items=tenants)


@router.post("/", response_model=TenantResponse, status_code=status.HTTP_201_CREATED)
def create_tenant(
    tenant_data: TenantCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role([UserRole.SYSTEM_ADMIN]))
):
    """
    Create a new tenant (System Admin only).
    """
    # Check if tenant with slug already exists
    existing = db.query(Tenant).filter(Tenant.slug == tenant_data.slug).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Tenant with this slug already exists"
        )
    
    tenant = Tenant(**tenant_data.dict())
    db.add(tenant)
    db.commit()
    db.refresh(tenant)
    
    # Log action
    log_action(
        db=db,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        action="tenant.created",
        resource_type="tenant",
        resource_id=tenant.id,
        description=f"Created tenant: {tenant.name}",
        new_values=tenant_data.dict()
    )
    
    return tenant


@router.get("/{tenant_id}", response_model=TenantResponse)
def get_tenant(
    tenant_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role([UserRole.SYSTEM_ADMIN]))
):
    """
    Get tenant by ID.
    """
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Tenant not found"
        )
    return tenant


@router.put("/{tenant_id}", response_model=TenantResponse)
def update_tenant(
    tenant_id: int,
    tenant_data: TenantUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role([UserRole.SYSTEM_ADMIN]))
):
    """
    Update tenant.
    """
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Tenant not found"
        )
    
    # Store old values for audit
    old_values = {
        "name": tenant.name,
        "contact_email": tenant.contact_email,
        "is_active": tenant.is_active
    }
    
    # Update fields
    for field, value in tenant_data.dict(exclude_unset=True).items():
        setattr(tenant, field, value)
    
    db.commit()
    db.refresh(tenant)
    
    # Log action
    log_action(
        db=db,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        action="tenant.updated",
        resource_type="tenant",
        resource_id=tenant.id,
        description=f"Updated tenant: {tenant.name}",
        old_values=old_values,
        new_values=tenant_data.dict(exclude_unset=True)
    )
    
    return tenant


@router.delete("/{tenant_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_tenant(
    tenant_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role([UserRole.SYSTEM_ADMIN]))
):
    """
    Delete tenant (soft delete by setting is_active=False).
    """
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Tenant not found"
        )
    
    tenant.is_active = False
    db.commit()
    
    # Log action
    log_action(
        db=db,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        action="tenant.deleted",
        resource_type="tenant",
        resource_id=tenant.id,
        description=f"Deleted tenant: {tenant.name}"
    )
    
    return None
======================================

======================================
File: time_tracking.py
Path: ./api/app/api/v1
--------------------------------------
# api/app/api/v1/time_tracking.py
"""
Time tracking endpoints for volunteer hours.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from typing import List, Optional
from datetime import datetime, timedelta
import hashlib
import secrets

from database import get_db
from models.user import User
from models.volunteer import Volunteer
from models.event import Event
from models.time_tracking import TimeEntry, EventQRCode, CheckinSession
from api.deps import get_current_user
from schemas.time_tracking import (
    TimeEntryCreate,
    TimeEntryBulkCreate,
    TimeEntryUpdate,
    TimeEntryResponse,
    TimeEntryApproval,
    BulkTimeEntryApproval,
    QRCodeCreate,
    QRCodeResponse,
    CheckinRequest,
    CheckoutRequest,
    CheckinResponse,
    VolunteerHoursReport,
    PendingApprovalsReport
)

router = APIRouter()


# =============== Time Entries ===============

@router.get("/entries", response_model=List[TimeEntryResponse])
def list_time_entries(
    volunteer_id: Optional[int] = None,
    event_id: Optional[int] = None,
    status: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List time entries with filters."""
    print(f"\n=== TIME ENTRIES API CALLED ===")
    print(f"User: {current_user.username} (tenant {current_user.tenant_id})")
    print(f"Filters: volunteer_id={volunteer_id}, event_id={event_id}, status={status}")
    
    query = db.query(TimeEntry).filter(
        TimeEntry.tenant_id == current_user.tenant_id
    )
    
    if volunteer_id:
        query = query.filter(TimeEntry.volunteer_id == volunteer_id)
    if event_id:
        query = query.filter(TimeEntry.event_id == event_id)
    if status:
        query = query.filter(TimeEntry.status == status)
    if start_date:
        query = query.filter(TimeEntry.check_in_time >= start_date)
    if end_date:
        query = query.filter(TimeEntry.check_in_time <= end_date)
    
    entries = query.order_by(TimeEntry.check_in_time.desc()).offset(skip).limit(limit).all()
    
    print(f"Found {len(entries)} entries")
    
    # Enhance with volunteer/event names
    result = []
    for entry in entries:
        volunteer_name = "Unknown Volunteer"
        event_name = None
        
        # Get volunteer info - don't fail if volunteer not found
        try:
            volunteer = db.query(Volunteer).filter(Volunteer.id == entry.volunteer_id).first()
            if volunteer:
                volunteer_name = f"{volunteer.first_name} {volunteer.last_name}"
            else:
                print(f"âš ï¸ Warning: Volunteer {entry.volunteer_id} not found for entry {entry.id}")
        except Exception as e:
            print(f"âš ï¸ Error fetching volunteer {entry.volunteer_id}: {e}")
        
        # Get event info - don't fail if event not found
        try:
            if entry.event_id:
                event = db.query(Event).filter(Event.id == entry.event_id).first()
                if event:
                    event_name = event.name
        except Exception as e:
            print(f"âš ï¸ Error fetching event {entry.event_id}: {e}")
        
        # Build response object
        entry_dict = {
            'id': entry.id,
            'tenant_id': entry.tenant_id,
            'volunteer_id': entry.volunteer_id,
            'event_id': entry.event_id,
            'shift_id': entry.shift_id,
            'check_in_time': entry.check_in_time,
            'check_out_time': entry.check_out_time,
            'duration_minutes': entry.duration_minutes,
            'hours_decimal': float(entry.hours_decimal) if entry.hours_decimal else None,
            'entry_method': entry.entry_method,
            'status': entry.status,
            'approved_by': entry.approved_by,
            'approved_at': entry.approved_at,
            'volunteer_notes': entry.volunteer_notes,
            'coordinator_notes': entry.coordinator_notes,
            'created_at': entry.created_at,
            'volunteer_name': volunteer_name,
            'event_name': event_name
        }
        
        print(f"  âœ“ Entry {entry.id}: {volunteer_name} - {entry.hours_decimal} hrs - {entry.status}")
        result.append(TimeEntryResponse(**entry_dict))
    
    print(f"Returning {len(result)} entries")
    print("=== END TIME ENTRIES API ===\n")
    
    return result


@router.post("/entries", response_model=TimeEntryResponse, status_code=status.HTTP_201_CREATED)
def create_time_entry(
    entry_data: TimeEntryCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a single time entry (manual or coordinator entry)."""
    # Verify volunteer exists
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == entry_data.volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Create time entry
    entry = TimeEntry(
        tenant_id=current_user.tenant_id,
        **entry_data.dict(),
        submitted_by=current_user.id,
        status='pending'  # Requires approval
    )
    
    # Calculate duration if check-out provided
    if entry.check_out_time:
        entry.calculate_duration()
    
    db.add(entry)
    db.commit()
    db.refresh(entry)
    
    return TimeEntryResponse(
        **entry.__dict__,
        volunteer_name=volunteer.full_name,
        event_name=entry.event.name if entry.event else None
    )


@router.post("/entries/bulk", status_code=status.HTTP_201_CREATED)
def create_bulk_time_entries(
    bulk_data: TimeEntryBulkCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Bulk create time entries (coordinator convenience feature)."""
    created_entries = []
    errors = []
    
    for entry_data in bulk_data.entries:
        try:
            volunteer = db.query(Volunteer).filter(
                Volunteer.id == entry_data['volunteer_id'],
                Volunteer.tenant_id == current_user.tenant_id
            ).first()
            
            if not volunteer:
                errors.append(f"Volunteer {entry_data['volunteer_id']} not found")
                continue
            
            entry = TimeEntry(
                tenant_id=current_user.tenant_id,
                volunteer_id=entry_data['volunteer_id'],
                event_id=bulk_data.event_id,
                check_in_time=entry_data['check_in_time'],
                check_out_time=entry_data.get('check_out_time'),
                volunteer_notes=entry_data.get('notes'),
                entry_method='manual',
                submitted_by=current_user.id,
                status='pending'
            )
            
            if entry.check_out_time:
                entry.calculate_duration()
            
            db.add(entry)
            created_entries.append(entry.id)
            
        except Exception as e:
            errors.append(f"Error for volunteer {entry_data.get('volunteer_id')}: {str(e)}")
    
    db.commit()
    
    return {
        "message": f"Created {len(created_entries)} time entries",
        "created_count": len(created_entries),
        "created_ids": created_entries,
        "errors": errors
    }


@router.patch("/entries/{entry_id}/approve", response_model=TimeEntryResponse)
def approve_time_entry(
    entry_id: int,
    approval: TimeEntryApproval,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Approve or reject a time entry."""
    entry = db.query(TimeEntry).filter(
        TimeEntry.id == entry_id,
        TimeEntry.tenant_id == current_user.tenant_id
    ).first()
    
    if not entry:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Time entry not found"
        )
    
    if entry.status != 'pending':
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Entry has already been processed"
        )
    
    # Update status
    entry.status = approval.status
    entry.approved_by = current_user.id
    entry.approved_at = datetime.utcnow()
    entry.coordinator_notes = approval.coordinator_notes
    
    if approval.status == 'rejected':
        entry.rejection_reason = approval.rejection_reason
    
    # Allow coordinator to override hours
    if approval.hours_override and approval.status == 'approved':
        entry.hours_decimal = approval.hours_override
        entry.duration_minutes = int(float(approval.hours_override) * 60)
    
    db.commit()
    db.refresh(entry)
    
    return TimeEntryResponse(
        **entry.__dict__,
        volunteer_name=entry.volunteer.full_name,
        event_name=entry.event.name if entry.event else None
    )


@router.post("/entries/bulk-approve")
def bulk_approve_entries(
    approval: BulkTimeEntryApproval,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Bulk approve or reject multiple time entries."""
    entries = db.query(TimeEntry).filter(
        TimeEntry.id.in_(approval.entry_ids),
        TimeEntry.tenant_id == current_user.tenant_id,
        TimeEntry.status == 'pending'
    ).all()
    
    if not entries:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No pending entries found"
        )
    
    updated_count = 0
    for entry in entries:
        entry.status = 'approved' if approval.action == 'approve' else 'rejected'
        entry.approved_by = current_user.id
        entry.approved_at = datetime.utcnow()
        if approval.notes:
            entry.coordinator_notes = approval.notes
        updated_count += 1
    
    db.commit()
    
    return {
        "message": f"{approval.action.capitalize()}d {updated_count} time entries",
        "updated_count": updated_count
    }


@router.get("/entries/pending", response_model=PendingApprovalsReport)
def get_pending_approvals(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all pending time entries requiring approval."""
    entries = db.query(TimeEntry).filter(
        TimeEntry.tenant_id == current_user.tenant_id,
        TimeEntry.status == 'pending'
    ).order_by(TimeEntry.check_in_time.desc()).all()
    
    total_hours = sum(float(e.hours_decimal or 0) for e in entries)
    oldest_date = min((e.check_in_time for e in entries), default=None)
    
    entry_responses = [
        TimeEntryResponse(
            **e.__dict__,
            volunteer_name=e.volunteer.full_name,
            event_name=e.event.name if e.event else None
        )
        for e in entries
    ]
    
    return PendingApprovalsReport(
        total_pending=len(entries),
        total_hours_pending=total_hours,
        oldest_entry_date=oldest_date,
        entries=entry_responses
    )


# =============== QR Codes ===============

@router.post("/qr-codes", response_model=QRCodeResponse, status_code=status.HTTP_201_CREATED)
def create_qr_code(
    qr_data: QRCodeCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Generate a QR code for an event or shift."""
    if not qr_data.event_id and not qr_data.shift_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Must specify either event_id or shift_id"
        )
    
    # Generate unique hash
    random_data = f"{qr_data.event_id}{qr_data.shift_id}{datetime.utcnow().isoformat()}{secrets.token_hex(16)}"
    qr_hash = hashlib.sha256(random_data.encode()).hexdigest()[:32]
    
    qr_code = EventQRCode(
        **qr_data.dict(),
        qr_code_hash=qr_hash,
        qr_code_url=f"https://vvhs.org/checkin/{qr_hash}",
        created_by=current_user.id
    )
    
    db.add(qr_code)
    db.commit()
    db.refresh(qr_code)
    
    return QRCodeResponse(
        **qr_code.__dict__,
        event_name=qr_code.event.name if qr_code.event else None
    )


@router.get("/events/{event_id}/qr-code", response_model=QRCodeResponse)
def get_event_qr_code(
    event_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get QR code for an event."""
    qr_code = db.query(EventQRCode).filter(
        EventQRCode.event_id == event_id,
        EventQRCode.is_active == True
    ).order_by(EventQRCode.created_at.desc()).first()
    
    if not qr_code:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No active QR code found for this event"
        )
    
    return QRCodeResponse(
        **qr_code.__dict__,
        event_name=qr_code.event.name if qr_code.event else None
    )


# =============== Check-in/Check-out ===============

@router.post("/checkin", response_model=CheckinResponse)
def volunteer_checkin(
    checkin: CheckinRequest,
    db: Session = Depends(get_db)
):
    """Volunteer check-in via QR code or direct entry."""
    # Verify QR code if provided
    qr_code = None
    if checkin.qr_code_hash:
        qr_code = db.query(EventQRCode).filter(
            EventQRCode.qr_code_hash == checkin.qr_code_hash
        ).first()
        
        if not qr_code or not qr_code.is_valid():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid or expired QR code"
            )
    
    # Get volunteer
    if not checkin.volunteer_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Volunteer ID is required"
        )
    
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == checkin.volunteer_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    # Create check-in session
    session = CheckinSession(
        volunteer_id=checkin.volunteer_id,
        event_id=checkin.event_id or (qr_code.event_id if qr_code else None),
        qr_code_id=qr_code.id if qr_code else None,
        check_in_time=datetime.utcnow(),
        device_info=str(checkin.device_info) if checkin.device_info else None,
        status='active'
    )
    
    db.add(session)
    
    # Create time entry
    time_entry = TimeEntry(
        tenant_id=volunteer.tenant_id,
        volunteer_id=volunteer.id,
        event_id=checkin.event_id or (qr_code.event_id if qr_code else None),
        check_in_time=datetime.utcnow(),
        entry_method='qr_code' if qr_code else 'kiosk',
        check_in_lat=checkin.latitude,
        check_in_lng=checkin.longitude,
        status='pending'
    )
    
    db.add(time_entry)
    
    # Update QR code use count
    if qr_code:
        qr_code.use_count += 1
    
    db.commit()
    db.refresh(session)
    db.refresh(time_entry)
    
    return CheckinResponse(
        success=True,
        message="Successfully checked in",
        session_id=session.id,
        time_entry_id=time_entry.id,
        volunteer_name=volunteer.full_name,
        event_name=time_entry.event.name if time_entry.event else None,
        check_in_time=time_entry.check_in_time
    )


@router.post("/checkout")
def volunteer_checkout(
    checkout: CheckoutRequest,
    db: Session = Depends(get_db)
):
    """Volunteer check-out."""
    time_entry = None
    
    if checkout.time_entry_id:
        time_entry = db.query(TimeEntry).filter(
            TimeEntry.id == checkout.time_entry_id
        ).first()
    elif checkout.session_id:
        session = db.query(CheckinSession).filter(
            CheckinSession.id == checkout.session_id,
            CheckinSession.status == 'active'
        ).first()
        
        if session:
            time_entry = db.query(TimeEntry).filter(
                TimeEntry.volunteer_id == session.volunteer_id,
                TimeEntry.event_id == session.event_id,
                TimeEntry.check_out_time.is_(None)
            ).order_by(TimeEntry.check_in_time.desc()).first()
            
            if session:
                session.check_out_time = datetime.utcnow()
                session.status = 'completed'
    
    if not time_entry:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No active check-in found"
        )
    
    # Update time entry
    time_entry.check_out_time = datetime.utcnow()
    time_entry.check_out_lat = checkout.latitude
    time_entry.check_out_lng = checkout.longitude
    if checkout.notes:
        time_entry.volunteer_notes = checkout.notes
    
    time_entry.calculate_duration()
    
    db.commit()
    
    return {
        "success": True,
        "message": "Successfully checked out",
        "hours": float(time_entry.hours_decimal or 0)
    }


# =============== Reports ===============

@router.get("/reports/volunteer-hours/{volunteer_id}", response_model=VolunteerHoursReport)
def get_volunteer_hours_report(
    volunteer_id: int,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get hours report for a specific volunteer."""
    volunteer = db.query(Volunteer).filter(
        Volunteer.id == volunteer_id,
        Volunteer.tenant_id == current_user.tenant_id
    ).first()
    
    if not volunteer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Volunteer not found"
        )
    
    query = db.query(TimeEntry).filter(TimeEntry.volunteer_id == volunteer_id)
    
    if start_date:
        query = query.filter(TimeEntry.check_in_time >= start_date)
    if end_date:
        query = query.filter(TimeEntry.check_in_time <= end_date)
    
    entries = query.all()
    
    total_hours = sum(float(e.hours_decimal or 0) for e in entries if e.hours_decimal)
    approved_hours = sum(float(e.hours_decimal or 0) for e in entries if e.status == 'approved' and e.hours_decimal)
    pending_hours = sum(float(e.hours_decimal or 0) for e in entries if e.status == 'pending' and e.hours_decimal)
    
    return VolunteerHoursReport(
        volunteer_id=volunteer.id,
        volunteer_name=volunteer.full_name,
        total_hours=total_hours,
        approved_hours=approved_hours,
        pending_hours=pending_hours,
        entry_count=len(entries),
        date_range_start=start_date,
        date_range_end=end_date
    )======================================

======================================
File: security.py
Path: ./api/app/core
--------------------------------------
"""
Security utilities for authentication and authorization.
Implements JWT tokens and password hashing (bcrypt) and token handling (JWT).
FIXED: Ensures 'sub' claim is always a string for JWT compliance.
"""
from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import JWTError, jwt
import bcrypt
from config import get_settings

settings = get_settings()

# ------------------------
# Password Hashing
# ------------------------

def get_password_hash(password: str) -> str:
    """
    Hash a password using bcrypt.
    Output format: $2b$12$<salt+hash>
    """
    hashed = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt(rounds=12))
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a password by comparing plaintext to stored hash.
    """
    return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))


# ------------------------
# JWT Tokens
# ------------------------

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create JWT access token.
    FIXED: Ensures 'sub' is always a string.
    """
    to_encode = data.copy()
    
    # Ensure 'sub' is a string (JWT standard requires it)
    if 'sub' in to_encode:
        to_encode['sub'] = str(to_encode['sub'])
    
    expire = datetime.utcnow() + (
        expires_delta if expires_delta else timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def create_refresh_token(data: dict) -> str:
    """
    Create JWT refresh token with longer expiration.
    FIXED: Ensures 'sub' is always a string.
    """
    to_encode = data.copy()
    
    # Ensure 'sub' is a string
    if 'sub' in to_encode:
        to_encode['sub'] = str(to_encode['sub'])
    
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def decode_token(token: str) -> dict:
    """
    Decode and validate JWT token.
    FIXED: Converts 'sub' back to integer after decoding.
    """
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        
        # Convert 'sub' back to integer if it's the user ID
        if 'sub' in payload and payload['sub'].isdigit():
            payload['sub'] = int(payload['sub'])
            
        return payload
    except JWTError as e:
        raise e======================================

======================================
File: permissions.py
Path: ./api/app/core
--------------------------------------
"""
Permission checking utilities for role-based access control.
Implements the permission model from requirements.
"""
from typing import List
from models.user import UserRole


class Permission:
    """Permission definitions matching requirements."""
    
    # System Administration
    MANAGE_TENANTS = "manage_tenants"
    MANAGE_SYSTEM_SETTINGS = "manage_system_settings"
    
    # User Management
    VIEW_ALL_USERS = "view_all_users"
    MANAGE_USERS = "manage_users"
    
    # Volunteer Management
    VIEW_VOLUNTEERS = "view_volunteers"
    EDIT_VOLUNTEERS = "edit_volunteers"
    APPROVE_VOLUNTEERS = "approve_volunteers"
    
    # Event Management
    VIEW_EVENTS = "view_events"
    CREATE_EVENTS = "create_events"
    EDIT_EVENTS = "edit_events"
    DELETE_EVENTS = "delete_events"
    
    # Scheduling
    ASSIGN_SHIFTS = "assign_shifts"
    MANAGE_WAITLIST = "manage_waitlist"
    
    # Communication
    VIEW_ALERTS = "view_alerts"
    SEND_ALERTS = "send_alerts"
    
    # Transfers
    INITIATE_TRANSFERS = "initiate_transfers"
    APPROVE_TRANSFERS = "approve_transfers"
    
    # Reports
    VIEW_REPORTS = "view_reports"
    EXPORT_DATA = "export_data"
    
    # Training
    VIEW_TRAINING = "view_training"
    EDIT_TRAINING = "edit_training"


# Role to permission mapping
ROLE_PERMISSIONS: dict[UserRole, List[str]] = {
    UserRole.SYSTEM_ADMIN: [
        # System admins have all permissions
        Permission.MANAGE_TENANTS,
        Permission.MANAGE_SYSTEM_SETTINGS,
        Permission.VIEW_ALL_USERS,
        Permission.MANAGE_USERS,
        Permission.VIEW_VOLUNTEERS,
        Permission.EDIT_VOLUNTEERS,
        Permission.APPROVE_VOLUNTEERS,
        Permission.VIEW_EVENTS,
        Permission.CREATE_EVENTS,
        Permission.EDIT_EVENTS,
        Permission.DELETE_EVENTS,
        Permission.ASSIGN_SHIFTS,
        Permission.MANAGE_WAITLIST,
        Permission.VIEW_ALERTS,
        Permission.SEND_ALERTS,
        Permission.INITIATE_TRANSFERS,
        Permission.APPROVE_TRANSFERS,
        Permission.VIEW_REPORTS,
        Permission.EXPORT_DATA,
        Permission.VIEW_TRAINING,
        Permission.EDIT_TRAINING,
    ],
    UserRole.ORG_ADMIN: [
        # Org admins (Unit Coordinators) have full tenant-level access
        Permission.MANAGE_USERS,
        Permission.VIEW_VOLUNTEERS,
        Permission.EDIT_VOLUNTEERS,
        Permission.APPROVE_VOLUNTEERS,
        Permission.VIEW_EVENTS,
        Permission.CREATE_EVENTS,
        Permission.EDIT_EVENTS,
        Permission.DELETE_EVENTS,
        Permission.ASSIGN_SHIFTS,
        Permission.MANAGE_WAITLIST,
        Permission.VIEW_ALERTS,
        Permission.SEND_ALERTS,
        Permission.INITIATE_TRANSFERS,
        Permission.APPROVE_TRANSFERS,
        Permission.VIEW_REPORTS,
        Permission.EXPORT_DATA,
        Permission.VIEW_TRAINING,
        Permission.EDIT_TRAINING,
    ],
    UserRole.COORDINATOR: [
        # Coordinators have management capabilities
        Permission.VIEW_VOLUNTEERS,
        Permission.EDIT_VOLUNTEERS,
        Permission.VIEW_EVENTS,
        Permission.CREATE_EVENTS,
        Permission.EDIT_EVENTS,
        Permission.ASSIGN_SHIFTS,
        Permission.MANAGE_WAITLIST,
        Permission.VIEW_ALERTS,
        Permission.SEND_ALERTS,
        Permission.VIEW_REPORTS,
        Permission.EXPORT_DATA,
        Permission.VIEW_TRAINING,
    ],
    UserRole.SUB_UNIT_STAFF: [
        # Sub-unit staff have view-only by default
        # Actual permissions set via user.can_* fields
        Permission.VIEW_VOLUNTEERS,
        Permission.VIEW_EVENTS,
        Permission.VIEW_ALERTS,
        Permission.VIEW_TRAINING,
    ],
    UserRole.VOLUNTEER: [
        # Volunteers have minimal permissions (for portal access)
        Permission.VIEW_EVENTS,
    ],
}


def has_permission(user_role: UserRole, permission: str, user_permissions: dict = None) -> bool:
    """
    Check if a user role has a specific permission.
    
    Args:
        user_role: User's role
        permission: Permission to check
        user_permissions: Optional dict of user-specific permissions (for sub-unit staff)
        
    Returns:
        True if user has permission, False otherwise
    """
    # Get base permissions for role
    base_permissions = ROLE_PERMISSIONS.get(user_role, [])
    
    if permission in base_permissions:
        return True
    
    # Check user-specific permissions for sub-unit staff
    if user_role == UserRole.SUB_UNIT_STAFF and user_permissions:
        permission_map = {
            Permission.EDIT_VOLUNTEERS: user_permissions.get("can_edit_data", False),
            Permission.SEND_ALERTS: user_permissions.get("can_edit_alerts", False),
            Permission.INITIATE_TRANSFERS: user_permissions.get("can_initiate_transfers", False),
            Permission.APPROVE_TRANSFERS: user_permissions.get("can_approve_transfers", False),
            Permission.EXPORT_DATA: user_permissions.get("can_export_data", False),
        }
        return permission_map.get(permission, False)
    
    return False


def get_user_permissions(user_role: UserRole, user_permissions: dict = None) -> List[str]:
    """
    Get all permissions for a user.
    
    Args:
        user_role: User's role
        user_permissions: Optional dict of user-specific permissions
        
    Returns:
        List of permission strings
    """
    permissions = ROLE_PERMISSIONS.get(user_role, []).copy()
    
    # Add user-specific permissions for sub-unit staff
    if user_role == UserRole.SUB_UNIT_STAFF and user_permissions:
        if user_permissions.get("can_edit_data"):
            permissions.append(Permission.EDIT_VOLUNTEERS)
        if user_permissions.get("can_edit_alerts"):
            permissions.append(Permission.SEND_ALERTS)
        if user_permissions.get("can_initiate_transfers"):
            permissions.append(Permission.INITIATE_TRANSFERS)
        if user_permissions.get("can_approve_transfers"):
            permissions.append(Permission.APPROVE_TRANSFERS)
        if user_permissions.get("can_export_data"):
            permissions.append(Permission.EXPORT_DATA)
    
    return permissions
======================================

======================================
File: main.py
Path: ./api/app
--------------------------------------
"""
FastAPI application entry point.
Main application configuration and router setup.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from config import get_settings
from database import engine, Base
from api.v1 import auth, tenants, users, volunteers, events, reports, integrations, scheduling, training, time_tracking, documents, reporting
import os

settings = get_settings()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    # Startup: Create database tables
    Base.metadata.create_all(bind=engine)
    print("âœ“ Database tables created")
    
    yield
    
    # Shutdown: Cleanup
    print("âœ“ Application shutdown")


# Create FastAPI application
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="Virginia Volunteer Health System - Multi-tenant SaaS for volunteer management",
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json",
    lifespan=lifespan
)

#origins = os.getenv("CORS_ORIGINS", "https://vvhs-saas.sitevision.com").split(",")
#
#
## Configure CORS
#app.add_middleware(
#    CORSMiddleware,
#    allow_origins=[
#        "http://localhost:3000",
#        "http://localhost:5173",
#        "https://vvhs-saas.sitevision.com",
#        "https://api.vvhs-saas.sitevision.com",
#        "*"  # Allow all origins for debugging
#    ],
#    allow_credentials=True,
#    allow_methods=["*"],
#    allow_headers=["*"],
#    expose_headers=["*"]
#)

origins = [
    o.strip() for o in os.getenv(
        "CORS_ORIGINS",
        "https://vvhs-saas.sitevision.com,https://api.vvhs-saas.sitevision.com"
    ).split(",") if o.strip()
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,                 
    allow_credentials=True,               
    allow_methods=["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
    allow_headers=["Authorization","Content-Type"]
)



# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint for monitoring."""
    return {
        "status": "healthy",
        "app_name": settings.APP_NAME,
        "version": settings.APP_VERSION
    }


# Include routers
app.include_router(auth.router, prefix="/api/v1/auth", tags=["Authentication"])
app.include_router(tenants.router, prefix="/api/v1/tenants", tags=["Tenants"])
app.include_router(users.router, prefix="/api/v1/users", tags=["Users"])
app.include_router(volunteers.router, prefix="/api/v1/volunteers", tags=["Volunteers"])
app.include_router(events.router, prefix="/api/v1/events", tags=["Events"])
app.include_router(reports.router, prefix="/api/v1/reports", tags=["Reports"])
app.include_router(integrations.router, prefix="/api/v1/integrations", tags=["Integrations"])
app.include_router(scheduling.router, prefix="/api/v1/scheduling", tags=["Scheduling"])
app.include_router(training.router, prefix="/api/v1/training", tags=["Training"])
app.include_router(time_tracking.router, prefix="/api/v1/time-tracking", tags=["Time Tracking"])
app.include_router(documents.router, prefix="/api/v1/documents", tags=["Documents"])
app.include_router(reporting.router, prefix="/api/v1/reporting", tags=["Reporting"])


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG
    )
======================================

======================================
File: config.py
Path: ./api/app
--------------------------------------
"""
Application configuration using Pydantic Settings.
Environment variables are loaded from .env file.
"""
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """Application settings with environment variable support."""
    
    # Application
    APP_NAME: str = "VVHS - Virginia Volunteer Health System"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # Database # Host should be in environment var but is @vvhs-db
    DATABASE_URL: str = "postgresql://vvhs:vvhs_password@vvhs-db:5432/vvhs_db"
    
    
    # Security
    SECRET_KEY: str = "devsecretkey"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # CORS
    # BACKEND_CORS_ORIGINS: list[str] = [
    # "https://vvhs-saas.sitevision.com",
    # "http://localhost:3000",
    # "http://localhost:5173"
    # ]

    # AWS S3 Configuration
    AWS_ACCESS_KEY_ID: str = "your-access-key-id"
    AWS_SECRET_ACCESS_KEY: str = "your-secret-access-key"
    AWS_REGION: str = "us-east-1"
    S3_BUCKET_NAME: str = "vvhs-documents"
    
    # TRAIN Integration (placeholder)
    TRAIN_API_URL: str = "https://api.train.org/v1"  # TODO: Add real TRAIN API endpoint
    TRAIN_API_KEY: str = "placeholder-api-key"
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()
======================================

======================================
File: 04_time_tracking.sql
Path: ./api/db_init
--------------------------------------
-- api/db_init/04_time_tracking.sql
-- Time Tracking & Check-In Schema
-- Implements section 1.5 from roadmap

-- Time Entries (volunteer hours)
CREATE TABLE time_entries (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    event_id INTEGER REFERENCES events(id) ON DELETE SET NULL,
    shift_id INTEGER REFERENCES shifts(id) ON DELETE SET NULL,
    
    -- Time tracking
    check_in_time TIMESTAMP NOT NULL,
    check_out_time TIMESTAMP,
    duration_minutes INTEGER,
    hours_decimal DECIMAL(5,2),
    
    -- Entry method
    entry_method VARCHAR(50) NOT NULL DEFAULT 'manual', -- manual, qr_code, kiosk, geolocation
    
    -- Geolocation (optional)
    check_in_lat DECIMAL(10,8),
    check_in_lng DECIMAL(11,8),
    check_out_lat DECIMAL(10,8),
    check_out_lng DECIMAL(11,8),
    location_verified BOOLEAN DEFAULT FALSE,
    
    -- Approval workflow
    status VARCHAR(50) NOT NULL DEFAULT 'pending', -- pending, approved, rejected, disputed
    submitted_by INTEGER REFERENCES users(id), -- Self-entry or coordinator
    approved_by INTEGER REFERENCES users(id),
    approved_at TIMESTAMP,
    rejection_reason TEXT,
    
    -- Notes
    volunteer_notes TEXT,
    coordinator_notes TEXT,
    dispute_notes TEXT,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CHECK (check_out_time IS NULL OR check_out_time > check_in_time),
    CHECK (hours_decimal >= 0)
);

-- QR Codes for events/shifts
CREATE TABLE event_qr_codes (
    id SERIAL PRIMARY KEY,
    event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,
    shift_id INTEGER REFERENCES shifts(id) ON DELETE CASCADE,
    
    -- QR Code data
    qr_code_hash VARCHAR(255) UNIQUE NOT NULL,
    qr_code_url VARCHAR(500),
    
    -- Validity
    valid_from TIMESTAMP NOT NULL,
    valid_until TIMESTAMP NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    max_uses INTEGER, -- NULL = unlimited
    use_count INTEGER DEFAULT 0,
    
    -- Configuration
    require_photo BOOLEAN DEFAULT FALSE,
    require_signature BOOLEAN DEFAULT FALSE,
    allow_early_checkin_minutes INTEGER DEFAULT 15,
    allow_late_checkout_minutes INTEGER DEFAULT 30,
    
    -- Metadata
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Check-in sessions (for kiosk/mobile)
CREATE TABLE checkin_sessions (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id),
    event_id INTEGER REFERENCES events(id),
    qr_code_id INTEGER REFERENCES event_qr_codes(id),
    
    -- Session data
    check_in_time TIMESTAMP NOT NULL,
    check_out_time TIMESTAMP,
    device_info JSONB, -- Device type, browser, etc.
    ip_address VARCHAR(45),
    
    -- Status
    status VARCHAR(50) DEFAULT 'active', -- active, completed, abandoned
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_time_entries_volunteer ON time_entries(volunteer_id, check_in_time);
CREATE INDEX idx_time_entries_event ON time_entries(event_id);
CREATE INDEX idx_time_entries_status ON time_entries(status);
CREATE INDEX idx_time_entries_pending ON time_entries(status, tenant_id) WHERE status = 'pending';
CREATE INDEX idx_event_qr_codes_hash ON event_qr_codes(qr_code_hash);
CREATE INDEX idx_checkin_sessions_volunteer ON checkin_sessions(volunteer_id);

-- Grant permissions
GRANT ALL PRIVILEGES ON time_entries TO vvhs;
GRANT ALL PRIVILEGES ON event_qr_codes TO vvhs;
GRANT ALL PRIVILEGES ON checkin_sessions TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;

-- Sample time entries for existing volunteers
INSERT INTO time_entries (tenant_id, volunteer_id, event_id, check_in_time, check_out_time, duration_minutes, hours_decimal, entry_method, status, approved_by) VALUES
-- Alice Anderson (volunteer_id = 1)
(1, 1, 1, '2025-11-01 08:00:00', '2025-11-01 16:00:00', 480, 8.00, 'manual', 'approved', 1),
(1, 1, 1, '2025-11-02 08:00:00', '2025-11-02 16:00:00', 480, 8.00, 'manual', 'approved', 1),
(1, 1, 1, '2025-11-03 09:00:00', '2025-11-03 15:00:00', 360, 6.00, 'qr_code', 'approved', 1),

-- Carol Clark (volunteer_id = 3)
(1, 3, 1, '2025-11-01 10:00:00', '2025-11-01 14:00:00', 240, 4.00, 'manual', 'approved', 1),
(1, 3, 2, '2025-11-05 09:00:00', '2025-11-05 17:00:00', 480, 8.00, 'manual', 'approved', 1),

-- Jane Doe (volunteer_id = 4) - pending approval
(2, 4, NULL, '2025-11-06 08:30:00', '2025-11-06 12:30:00', 240, 4.00, 'manual', 'pending', NULL),
(2, 4, NULL, '2025-11-07 13:00:00', '2025-11-07 17:00:00', 240, 4.00, 'qr_code', 'pending', NULL);

-- Sample QR codes for upcoming events
INSERT INTO event_qr_codes (event_id, qr_code_hash, qr_code_url, valid_from, valid_until, is_active, created_by) VALUES
(1, 'qr_event1_2025', 'https://vvhs.org/checkin/qr_event1_2025', 
 '2025-11-20 07:00:00', '2025-11-20 19:00:00', true, 1),
(2, 'qr_event2_2025', 'https://vvhs.org/checkin/qr_event2_2025',
 '2025-12-05 08:00:00', '2025-12-05 18:00:00', true, 1);

-- Comments
COMMENT ON TABLE time_entries IS 'Volunteer time tracking and hour entries';
COMMENT ON TABLE event_qr_codes IS 'QR codes for event/shift check-in';
COMMENT ON TABLE checkin_sessions IS 'Active check-in sessions for mobile/kiosk';======================================

======================================
File: 05_document_management.sql
Path: ./api/db_init
--------------------------------------
-- Add to db_init/05_document_management.sql

-- Policy Documents Library
CREATE TABLE policy_documents (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    
    -- Document info
    title VARCHAR(255) NOT NULL,
    description TEXT,
    document_type VARCHAR(100) NOT NULL, -- waiver, policy, guideline, etc.
    version VARCHAR(50) NOT NULL,
    
    -- File storage
    file_url VARCHAR(500) NOT NULL,
    file_size_bytes INTEGER,
    file_hash VARCHAR(255), -- SHA-256 for integrity
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    requires_signature BOOLEAN DEFAULT FALSE,
    
    -- Metadata
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    effective_date DATE,
    expiration_date DATE,
    
    -- Track superseded documents
    supersedes_document_id INTEGER REFERENCES policy_documents(id),
    
    CONSTRAINT unique_active_policy UNIQUE(tenant_id, document_type, version) WHERE is_active = TRUE
);

-- Electronic Signatures
CREATE TABLE electronic_signatures (
    id SERIAL PRIMARY KEY,
    
    -- Who signed
    volunteer_id INTEGER REFERENCES volunteers(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id), -- Staff can also sign
    
    -- What was signed
    policy_document_id INTEGER REFERENCES policy_documents(id),
    custom_document_id INTEGER REFERENCES volunteer_documents(id), -- For uploaded docs
    
    -- Signature data
    signature_data TEXT, -- Base64 encoded signature image or typed name
    signature_method VARCHAR(50) NOT NULL, -- drawn, typed, click_through
    
    -- Legal requirements for non-repudiation
    ip_address VARCHAR(45) NOT NULL,
    user_agent TEXT,
    geolocation JSONB, -- {lat, lng, accuracy}
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Consent acknowledgment
    consent_text TEXT NOT NULL, -- Exact text shown to signer
    acknowledged_terms BOOLEAN DEFAULT TRUE,
    
    -- Verification
    verified BOOLEAN DEFAULT FALSE,
    verification_method VARCHAR(100),
    verified_at TIMESTAMP,
    verified_by INTEGER REFERENCES users(id)
);

-- Volunteer Documents (enhanced)
CREATE TABLE volunteer_documents (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id),
    
    -- Document classification
    document_type VARCHAR(100) NOT NULL, -- photo_id, license, certification, insurance, waiver
    document_category VARCHAR(100), -- identity, credential, legal
    title VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- File storage
    file_url VARCHAR(500) NOT NULL,
    file_name VARCHAR(255),
    file_size_bytes INTEGER,
    file_type VARCHAR(50), -- pdf, jpg, png
    file_hash VARCHAR(255), -- SHA-256
    
    -- Expiration tracking
    issue_date DATE,
    expiration_date DATE,
    expires BOOLEAN DEFAULT FALSE,
    
    -- Verification workflow
    verification_status VARCHAR(50) DEFAULT 'pending', -- pending, approved, rejected, expired
    verified_by INTEGER REFERENCES users(id),
    verified_at TIMESTAMP,
    rejection_reason TEXT,
    
    -- Access control
    visibility VARCHAR(50) DEFAULT 'private', -- private, tenant_admins, public
    
    -- Notifications
    expiration_notified BOOLEAN DEFAULT FALSE,
    last_notification_date DATE,
    
    -- Metadata
    uploaded_by INTEGER REFERENCES users(id),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Audit
    download_count INTEGER DEFAULT 0,
    last_accessed_at TIMESTAMP
);

-- Document Access Log (audit trail)
CREATE TABLE document_access_log (
    id BIGSERIAL PRIMARY KEY,
    
    -- What was accessed
    document_id INTEGER,
    document_type VARCHAR(100), -- policy_document, volunteer_document
    
    -- Who accessed
    user_id INTEGER REFERENCES users(id),
    volunteer_id INTEGER REFERENCES volunteers(id),
    
    -- How accessed
    action VARCHAR(50) NOT NULL, -- view, download, upload, delete, sign
    ip_address VARCHAR(45),
    user_agent TEXT,
    
    -- When
    accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Context
    metadata JSONB
);

-- Indexes
CREATE INDEX idx_policy_docs_tenant ON policy_documents(tenant_id, is_active);
CREATE INDEX idx_policy_docs_type ON policy_documents(document_type);
CREATE INDEX idx_signatures_volunteer ON electronic_signatures(volunteer_id);
CREATE INDEX idx_signatures_policy ON electronic_signatures(policy_document_id);
CREATE INDEX idx_volunteer_docs_volunteer ON volunteer_documents(volunteer_id);
CREATE INDEX idx_volunteer_docs_expiration ON volunteer_documents(expiration_date) WHERE expires = TRUE;
CREATE INDEX idx_volunteer_docs_status ON volunteer_documents(verification_status);
CREATE INDEX idx_doc_access_log ON document_access_log(document_type, document_id, accessed_at);

-- Permissions
GRANT ALL PRIVILEGES ON policy_documents TO vvhs;
GRANT ALL PRIVILEGES ON electronic_signatures TO vvhs;
GRANT ALL PRIVILEGES ON volunteer_documents TO vvhs;
GRANT ALL PRIVILEGES ON document_access_log TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;======================================

======================================
File: 03_training.sql
Path: ./api/db_init
--------------------------------------
-- api/db_init/03_training.sql (ENHANCED - Training Management)
-- Training Management Schema
-- Implements section 1.4 from roadmap

-- Training Courses (including TRAIN courses)
CREATE TABLE training_courses (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    
    -- TRAIN Integration
    train_course_id VARCHAR(100) UNIQUE,
    
    -- Course Information
    name VARCHAR(255) NOT NULL,
    description TEXT,
    course_code VARCHAR(50),
    provider VARCHAR(255),
    category VARCHAR(100),
    
    -- Requirements
    is_required BOOLEAN DEFAULT FALSE,
    validity_period_days INTEGER,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Volunteer Training Records
CREATE TABLE volunteer_training (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    course_id INTEGER NOT NULL REFERENCES training_courses(id),
    
    -- Completion Details
    completion_date DATE NOT NULL,
    expiration_date DATE,
    score DECIMAL(5,2),
    certificate_number VARCHAR(100),
    certificate_url VARCHAR(500),
    
    -- TRAIN Sync
    train_completion_id VARCHAR(100) UNIQUE,
    synced_from_train BOOLEAN DEFAULT FALSE,
    last_sync_date TIMESTAMP,
    
    -- Status
    status VARCHAR(50) DEFAULT 'active',
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(volunteer_id, course_id, completion_date)
);

-- Professional Certifications
CREATE TABLE certifications (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    
    -- Certification Details
    certification_type VARCHAR(100) NOT NULL,
    license_number VARCHAR(100),
    issuing_authority VARCHAR(255),
    
    -- Dates
    issue_date DATE,
    expiration_date DATE,
    
    -- Verification
    verification_status VARCHAR(50) DEFAULT 'pending',
    verification_date DATE,
    verification_method VARCHAR(100),
    verified_by INTEGER REFERENCES users(id),
    
    -- Document
    document_url VARCHAR(500),
    document_type VARCHAR(50),
    
    -- Notes
    notes TEXT,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Training Requirements
CREATE TABLE training_requirements (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    
    -- Requirement Details
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Linked Course
    course_id INTEGER REFERENCES training_courses(id),
    
    -- Applicability
    required_for_roles TEXT,
    required_for_event_types TEXT,
    
    -- Grace Period
    grace_period_days INTEGER DEFAULT 0,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_training_courses_tenant ON training_courses(tenant_id);
CREATE INDEX idx_training_courses_train_id ON training_courses(train_course_id);
CREATE INDEX idx_volunteer_training_volunteer ON volunteer_training(volunteer_id);
CREATE INDEX idx_volunteer_training_course ON volunteer_training(course_id);
CREATE INDEX idx_volunteer_training_expiration ON volunteer_training(expiration_date);
CREATE INDEX idx_certifications_volunteer ON certifications(volunteer_id);
CREATE INDEX idx_certifications_expiration ON certifications(expiration_date);

-- Grant permissions
GRANT ALL PRIVILEGES ON training_courses TO vvhs;
GRANT ALL PRIVILEGES ON volunteer_training TO vvhs;
GRANT ALL PRIVILEGES ON certifications TO vvhs;
GRANT ALL PRIVILEGES ON training_requirements TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;

-- Insert TRAIN courses (more comprehensive list)
INSERT INTO training_courses (tenant_id, train_course_id, name, description, course_code, provider, category, is_required, validity_period_days) VALUES
-- Emergency Management (FEMA)
(1, 'TRAIN-ICS100', 'ICS 100: Introduction to Incident Command System', 'Basic incident command system training', 'ICS-100', 'FEMA', 'Emergency Management', true, 1460),
(1, 'TRAIN-ICS200', 'ICS 200: ICS for Single Resources', 'Intermediate incident command system', 'ICS-200', 'FEMA', 'Emergency Management', true, 1460),
(1, 'TRAIN-ICS300', 'ICS 300: Intermediate ICS', 'Advanced incident command for supervisors', 'ICS-300', 'FEMA', 'Emergency Management', false, 1460),
(1, 'TRAIN-ICS400', 'ICS 400: Advanced ICS', 'Advanced ICS for command staff', 'ICS-400', 'FEMA', 'Emergency Management', false, 1460),
(1, 'TRAIN-NIMS700', 'IS-700: National Incident Management System', 'NIMS overview', 'IS-700', 'FEMA', 'Emergency Management', true, NULL),
(1, 'TRAIN-NIMS800', 'IS-800: National Response Framework', 'NRF overview', 'IS-800', 'FEMA', 'Emergency Management', true, NULL),

-- Medical Training
(1, 'TRAIN-CPR', 'CPR/AED for Healthcare Providers', 'CPR and AED training', 'CPR-HEALTH', 'American Heart Association', 'Medical', true, 730),
(1, 'TRAIN-BLS', 'Basic Life Support (BLS)', 'Basic life support for healthcare', 'BLS', 'American Heart Association', 'Medical', true, 730),
(1, 'TRAIN-ACLS', 'Advanced Cardiac Life Support', 'Advanced cardiac life support', 'ACLS', 'American Heart Association', 'Medical', false, 730),
(1, 'TRAIN-PALS', 'Pediatric Advanced Life Support', 'Pediatric advanced life support', 'PALS', 'American Heart Association', 'Medical', false, 730),
(1, 'TRAIN-FIRST-AID', 'First Aid Certification', 'Basic first aid', 'FIRST-AID', 'American Red Cross', 'Medical', false, 730),

-- Public Health & Compliance
(1, 'TRAIN-HIPAA', 'HIPAA Privacy and Security', 'HIPAA compliance', 'HIPAA-101', 'VDH', 'Compliance', true, 365),
(1, 'TRAIN-INFECTION', 'Infection Control and Prevention', 'Standard precautions', 'INFECT-PREV', 'CDC', 'Medical', true, 365),
(1, 'TRAIN-VAX', 'Vaccine Administration Training', 'Vaccine administration', 'VAX-ADMIN', 'CDC', 'Medical', false, NULL),
(1, 'TRAIN-VAX-STORAGE', 'Vaccine Storage and Handling', 'Proper vaccine storage', 'VAX-STORE', 'CDC', 'Medical', false, NULL),

-- Specialized Training
(1, 'TRAIN-DISASTER-MED', 'Disaster Medicine', 'Medical response in disasters', 'DM-101', 'NDMS', 'Emergency Management', false, NULL),
(1, 'TRAIN-MENTAL-HEALTH', 'Psychological First Aid', 'Mental health in disasters', 'PFA', 'SAMHSA', 'Behavioral Health', false, NULL),
(1, 'TRAIN-SHELTER-OPS', 'Shelter Operations', 'Emergency shelter management', 'SHELTER-101', 'American Red Cross', 'Emergency Management', false, NULL);

-- Insert volunteer training records (comprehensive for tenant 1 volunteers)
INSERT INTO volunteer_training (volunteer_id, course_id, completion_date, expiration_date, score, train_completion_id, synced_from_train, status) VALUES
-- Alice Anderson (volunteer 1) - Fully trained senior volunteer
(1, 1, '2023-01-15', '2027-01-15', 95.0, 'TRAIN-COMP-1-1', true, 'active'),
(1, 2, '2023-02-20', '2027-02-20', 92.0, 'TRAIN-COMP-1-2', true, 'active'),
(1, 5, '2023-03-10', NULL, 98.0, 'TRAIN-COMP-1-5', true, 'active'),
(1, 6, '2023-03-15', NULL, 96.0, 'TRAIN-COMP-1-6', true, 'active'),
(1, 7, '2024-01-10', '2026-01-10', 100.0, 'TRAIN-COMP-1-7', true, 'active'),
(1, 8, '2024-01-10', '2026-01-10', 98.0, 'TRAIN-COMP-1-8', true, 'active'),
(1, 9, '2024-02-15', '2026-02-15', 97.0, 'TRAIN-COMP-1-9', true, 'active'),
(1, 10, '2024-03-01', '2026-03-01', 99.0, 'TRAIN-COMP-1-10', true, 'active'),
(1, 12, '2025-01-01', '2026-01-01', 100.0, 'TRAIN-COMP-1-12', true, 'active'),
(1, 13, '2024-12-01', '2025-12-01', 95.0, 'TRAIN-COMP-1-13', true, 'active'),

-- Bob Brown (volunteer 2) - Some expired
(2, 1, '2021-03-15', '2025-03-15', 88.0, 'TRAIN-COMP-2-1', true, 'expired'),
(2, 7, '2022-06-01', '2024-06-01', 90.0, 'TRAIN-COMP-2-7', true, 'expired'),
(2, 12, '2024-01-01', '2025-01-01', 95.0, 'TRAIN-COMP-2-12', true, 'active'),

-- Carol Clark (volunteer 3) - Medical professional, comprehensive
(3, 1, '2024-05-10', '2028-05-10', 100.0, 'TRAIN-COMP-3-1', true, 'active'),
(3, 2, '2024-06-01', '2028-06-01', 100.0, 'TRAIN-COMP-3-2', true, 'active'),
(3, 5, '2024-05-15', NULL, 100.0, 'TRAIN-COMP-3-5', true, 'active'),
(3, 7, '2024-11-01', '2026-11-01', 100.0, 'TRAIN-COMP-3-7', true, 'active'),
(3, 8, '2024-11-01', '2026-11-01', 100.0, 'TRAIN-COMP-3-8', true, 'active'),
(3, 9, '2024-09-15', '2026-09-15', 100.0, 'TRAIN-COMP-3-9', true, 'active'),
(3, 12, '2025-01-15', '2026-01-15', 100.0, 'TRAIN-COMP-3-12', true, 'active'),
(3, 13, '2025-01-20', '2026-01-20', 100.0, 'TRAIN-COMP-3-13', true, 'active'),
(3, 16, '2024-08-10', NULL, 98.0, 'TRAIN-COMP-3-16', true, 'active'),

-- David Davis (volunteer 4) - Paramedic
(4, 1, '2024-03-01', '2028-03-01', 94.0, 'TRAIN-COMP-4-1', true, 'active'),
(4, 7, '2024-02-10', '2026-02-10', 96.0, 'TRAIN-COMP-4-7', true, 'active'),
(4, 8, '2024-02-10', '2026-02-10', 95.0, 'TRAIN-COMP-4-8', true, 'active'),
(4, 9, '2024-03-15', '2026-03-15', 97.0, 'TRAIN-COMP-4-9', true, 'active'),
(4, 10, '2024-03-20', '2026-03-20', 98.0, 'TRAIN-COMP-4-10', true, 'active'),
(4, 12, '2024-11-01', '2025-11-01', 100.0, 'TRAIN-COMP-4-12', true, 'active'),

-- Emma Evans (volunteer 5) - RN Pediatric
(5, 1, '2024-05-01', '2028-05-01', 92.0, 'TRAIN-COMP-5-1', true, 'active'),
(5, 7, '2024-06-15', '2026-06-15', 95.0, 'TRAIN-COMP-5-7', true, 'active'),
(5, 8, '2024-06-15', '2026-06-15', 94.0, 'TRAIN-COMP-5-8', true, 'active'),
(5, 10, '2024-07-01', '2026-07-01', 98.0, 'TRAIN-COMP-5-10', true, 'active'),
(5, 12, '2024-10-15', '2025-10-15', 96.0, 'TRAIN-COMP-5-12', true, 'active'),
(5, 14, '2024-08-20', NULL, 94.0, 'TRAIN-COMP-5-14', true, 'active'),

-- Frank Foster (volunteer 6) - EMT
(6, 1, '2024-06-01', '2028-06-01', 89.0, 'TRAIN-COMP-6-1', true, 'active'),
(6, 7, '2024-08-10', '2026-08-10', 91.0, 'TRAIN-COMP-6-7', true, 'active'),
(6, 12, '2024-09-15', '2025-09-15', 93.0, 'TRAIN-COMP-6-12', true, 'active'),

-- Grace Garcia (volunteer 7) - PA
(7, 1, '2024-06-20', '2028-06-20', 96.0, 'TRAIN-COMP-7-1', true, 'active'),
(7, 5, '2024-07-01', NULL, 97.0, 'TRAIN-COMP-7-5', true, 'active'),
(7, 7, '2024-05-10', '2026-05-10', 98.0, 'TRAIN-COMP-7-7', true, 'active'),
(7, 8, '2024-05-10', '2026-05-10', 97.0, 'TRAIN-COMP-7-8', true, 'active'),
(7, 9, '2024-06-05', '2026-06-05', 99.0, 'TRAIN-COMP-7-9', true, 'active'),
(7, 12, '2024-11-10', '2025-11-10', 95.0, 'TRAIN-COMP-7-12', true, 'active'),

-- Henry Harris (volunteer 8) - ICU RN
(8, 1, '2024-07-15', '2028-07-15', 93.0, 'TRAIN-COMP-8-1', true, 'active'),
(8, 7, '2024-03-20', '2026-03-20', 96.0, 'TRAIN-COMP-8-7', true, 'active'),
(8, 8, '2024-03-20', '2026-03-20', 95.0, 'TRAIN-COMP-8-8', true, 'active'),
(8, 9, '2024-04-10', '2026-04-10', 98.0, 'TRAIN-COMP-8-9', true, 'active'),
(8, 12, '2024-10-05', '2025-10-05', 97.0, 'TRAIN-COMP-8-12', true, 'active'),
(8, 13, '2024-09-20', '2025-09-20', 96.0, 'TRAIN-COMP-8-13', true, 'active'),

-- Isabel Ingram (volunteer 9) - Pharmacist
(9, 1, '2024-08-10', '2028-08-10', 91.0, 'TRAIN-COMP-9-1', true, 'active'),
(9, 7, '2024-07-01', '2026-07-01', 93.0, 'TRAIN-COMP-9-7', true, 'active'),
(9, 12, '2024-10-20', '2025-10-20', 95.0, 'TRAIN-COMP-9-12', true, 'active'),
(9, 14, '2024-08-25', NULL, 97.0, 'TRAIN-COMP-9-14', true, 'active'),
(9, 15, '2024-09-05', NULL, 96.0, 'TRAIN-COMP-9-15', true, 'active'),

-- Jack Jackson (volunteer 10) - Student
(10, 7, '2024-09-01', '2026-09-01', 88.0, 'TRAIN-COMP-10-7', true, 'active'),
(10, 8, '2024-09-01', '2026-09-01', 87.0, 'TRAIN-COMP-10-8', true, 'active'),
(10, 12, '2024-10-10', '2025-10-10', 90.0, 'TRAIN-COMP-10-12', true, 'active');

-- Insert certifications (comprehensive for all volunteers)
INSERT INTO certifications (volunteer_id, certification_type, license_number, issuing_authority, issue_date, expiration_date, verification_status, verified_by) VALUES
-- Alice Anderson
(1, 'Registered Nurse (RN)', 'RN123456', 'Virginia Board of Nursing', '2020-01-15', '2027-01-15', 'verified', 1),
(1, 'Basic Life Support (BLS)', 'BLS-987654', 'American Heart Association', '2024-01-10', '2026-01-10', 'verified', 1),
(1, 'Advanced Cardiovascular Life Support (ACLS)', 'ACLS-456789', 'American Heart Association', '2024-02-15', '2026-02-15', 'verified', 1),
(1, 'Pediatric Advanced Life Support (PALS)', 'PALS-123789', 'American Heart Association', '2024-03-01', '2026-03-01', 'verified', 1),

-- Bob Brown
(2, 'Emergency Medical Technician (EMT)', 'EMT789012', 'Virginia Office of EMS', '2022-06-01', '2025-06-01', 'verified', 1),
(2, 'CPR/AED', 'CPR-112233', 'American Red Cross', '2024-03-15', '2026-03-15', 'verified', 1),

-- Carol Clark
(3, 'Medical Doctor (MD)', 'MD456789', 'Virginia Board of Medicine', '2015-07-01', '2027-12-31', 'verified', 1),
(3, 'Board Certified - Internal Medicine', 'ABIM-789012', 'American Board of Internal Medicine', '2016-01-01', NULL, 'verified', 1),
(4, 'Registered Nurse (RN)', 'RN654321', 'Virginia Board of Nursing', '2018-05-15', '2026-05-15', 'verified', 1),
(4, 'CPR/BLS', 'BLS-445566', 'American Heart Association', '2024-10-15', '2026-10-15', 'verified', 1);

-- Comments
COMMENT ON TABLE training_courses IS 'Catalog of training courses including TRAIN courses';
COMMENT ON TABLE volunteer_training IS 'Training completion records for volunteers';
COMMENT ON TABLE certifications IS 'Professional licenses and certifications';
COMMENT ON TABLE training_requirements IS 'Training requirements for specific roles/events';======================================

======================================
File: 06_reporting.sql
Path: ./api/db_init
--------------------------------------
-- api/db_init/06_reporting.sql
-- Reporting & Analytics Schema
-- Implements section 1.7 from roadmap

-- Saved Reports Library
CREATE TABLE saved_reports (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    
    -- Report metadata
    name VARCHAR(255) NOT NULL,
    description TEXT,
    report_type VARCHAR(100) NOT NULL, -- volunteer_hours, impact_data, compliance, etc.
    
    -- Report configuration
    query_config JSONB NOT NULL, -- Field selections, filters, groupings
    visualization_config JSONB, -- Chart type, colors, etc.
    
    -- Scheduling
    schedule_config JSONB, -- {frequency: 'daily', time: '08:00', recipients: ['email@example.com']}
    last_generated_at TIMESTAMP,
    next_scheduled_at TIMESTAMP,
    
    -- Sharing
    is_public BOOLEAN DEFAULT FALSE,
    shared_with_roles TEXT, -- JSON array of roles
    shared_with_users TEXT, -- JSON array of user IDs
    
    -- Ownership
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE
);

-- Report Executions History
CREATE TABLE report_executions (
    id SERIAL PRIMARY KEY,
    report_id INTEGER REFERENCES saved_reports(id) ON DELETE CASCADE,
    
    -- Execution details
    executed_by INTEGER REFERENCES users(id),
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    execution_time_ms INTEGER,
    row_count INTEGER,
    
    -- Output
    file_url VARCHAR(500), -- S3 URL for generated file
    file_format VARCHAR(20), -- excel, pdf, csv
    file_size_bytes INTEGER,
    
    -- Status
    status VARCHAR(50) DEFAULT 'pending', -- pending, completed, failed
    error_message TEXT
);

-- Report Builder Field Definitions
CREATE TABLE report_fields (
    id SERIAL PRIMARY KEY,
    entity_type VARCHAR(100) NOT NULL, -- volunteer, event, training, time_entry
    field_name VARCHAR(100) NOT NULL,
    field_label VARCHAR(255) NOT NULL,
    field_type VARCHAR(50) NOT NULL, -- string, number, date, boolean
    is_filterable BOOLEAN DEFAULT TRUE,
    is_groupable BOOLEAN DEFAULT TRUE,
    is_aggregatable BOOLEAN DEFAULT FALSE,
    aggregation_functions TEXT, -- JSON array: ['sum', 'avg', 'count']
    UNIQUE(entity_type, field_name)
);

-- Workflow Automation Rules
CREATE TABLE report_workflows (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    
    -- Workflow details
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Trigger configuration
    trigger_report_id INTEGER REFERENCES saved_reports(id),
    trigger_conditions JSONB, -- Filter conditions that must be met
    
    -- Actions to perform
    actions JSONB NOT NULL, -- [{type: 'add_to_group', group_id: 123}, {type: 'send_email', template_id: 456}]
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    last_executed_at TIMESTAMP,
    execution_count INTEGER DEFAULT 0,
    
    -- Metadata
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Workflow Execution Log
CREATE TABLE workflow_executions (
    id SERIAL PRIMARY KEY,
    workflow_id INTEGER REFERENCES report_workflows(id) ON DELETE CASCADE,
    
    -- Execution details
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    records_processed INTEGER,
    records_affected INTEGER,
    
    -- Status
    status VARCHAR(50) DEFAULT 'pending',
    error_message TEXT,
    execution_log JSONB -- Detailed log of actions performed
);

-- Indexes for performance
CREATE INDEX idx_saved_reports_tenant ON saved_reports(tenant_id, is_active);
CREATE INDEX idx_saved_reports_type ON saved_reports(report_type);
CREATE INDEX idx_report_executions_report ON report_executions(report_id, executed_at);
CREATE INDEX idx_report_workflows_tenant ON report_workflows(tenant_id, is_active);
CREATE INDEX idx_workflow_executions_workflow ON workflow_executions(workflow_id, executed_at);

-- Permissions
GRANT ALL PRIVILEGES ON saved_reports TO vvhs;
GRANT ALL PRIVILEGES ON report_executions TO vvhs;
GRANT ALL PRIVILEGES ON report_fields TO vvhs;
GRANT ALL PRIVILEGES ON report_workflows TO vvhs;
GRANT ALL PRIVILEGES ON workflow_executions TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;

-- Insert report field definitions
INSERT INTO report_fields (entity_type, field_name, field_label, field_type, is_filterable, is_groupable, is_aggregatable, aggregation_functions) VALUES
-- Volunteer fields
('volunteer', 'id', 'Volunteer ID', 'number', TRUE, TRUE, TRUE, '["count"]'),
('volunteer', 'full_name', 'Full Name', 'string', TRUE, TRUE, FALSE, NULL),
('volunteer', 'email', 'Email', 'string', TRUE, FALSE, FALSE, NULL),
('volunteer', 'application_status', 'Application Status', 'string', TRUE, TRUE, TRUE, '["count"]'),
('volunteer', 'account_status', 'Account Status', 'string', TRUE, TRUE, TRUE, '["count"]'),
('volunteer', 'total_hours', 'Total Hours', 'number', TRUE, FALSE, TRUE, '["sum", "avg", "min", "max"]'),
('volunteer', 'created_at', 'Registration Date', 'date', TRUE, TRUE, TRUE, '["count"]'),
('volunteer', 'city', 'City', 'string', TRUE, TRUE, TRUE, '["count"]'),
('volunteer', 'state', 'State', 'string', TRUE, TRUE, TRUE, '["count"]'),

-- Training fields
('training', 'course_name', 'Course Name', 'string', TRUE, TRUE, TRUE, '["count"]'),
('training', 'completion_date', 'Completion Date', 'date', TRUE, TRUE, TRUE, '["count"]'),
('training', 'expiration_date', 'Expiration Date', 'date', TRUE, TRUE, TRUE, '["count"]'),
('training', 'status', 'Training Status', 'string', TRUE, TRUE, TRUE, '["count"]'),

-- Event fields
('event', 'name', 'Event Name', 'string', TRUE, TRUE, TRUE, '["count"]'),
('event', 'activity_type', 'Activity Type', 'string', TRUE, TRUE, TRUE, '["count"]'),
('event', 'start_date', 'Event Date', 'date', TRUE, TRUE, TRUE, '["count"]'),
('event', 'location', 'Location', 'string', TRUE, TRUE, TRUE, '["count"]'),
('event', 'registered_volunteers', 'Registered Volunteers', 'number', TRUE, FALSE, TRUE, '["sum", "avg", "min", "max"]'),

-- Time Entry fields
('time_entry', 'check_in_time', 'Check In Time', 'date', TRUE, TRUE, TRUE, '["count"]'),
('time_entry', 'hours_decimal', 'Hours', 'number', TRUE, FALSE, TRUE, '["sum", "avg", "min", "max"]'),
('time_entry', 'status', 'Approval Status', 'string', TRUE, TRUE, TRUE, '["count"]'),
('time_entry', 'entry_method', 'Entry Method', 'string', TRUE, TRUE, TRUE, '["count"]');

COMMENT ON TABLE saved_reports IS 'User-defined and system reports';
COMMENT ON TABLE report_executions IS 'History of report generations';
COMMENT ON TABLE report_fields IS 'Available fields for report builder';
COMMENT ON TABLE report_workflows IS 'Automated workflows triggered by report results';======================================

======================================
File: 02_init.sql
Path: ./api/db_init
--------------------------------------
-- api/db_init/02_init.sql (ENHANCED - Advanced Scheduling)
-- Advanced Scheduling & Shift Management Tables
-- Implements section 1.2 from the roadmap

-- Shift Templates for recurring shift creation
CREATE TABLE shift_templates (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Recurrence pattern
    recurrence_pattern JSONB,
    duration_minutes INTEGER NOT NULL,
    
    -- Capacity
    max_volunteers INTEGER,
    min_volunteers INTEGER DEFAULT 1,
    
    -- Requirements
    required_skills JSONB,
    required_training JSONB,
    
    -- Configuration
    is_active BOOLEAN DEFAULT TRUE,
    allow_self_signup BOOLEAN DEFAULT FALSE,
    enable_waitlist BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Shift Waitlist Queue
CREATE TABLE shift_waitlists (
    id SERIAL PRIMARY KEY,
    shift_id INTEGER NOT NULL REFERENCES shifts(id) ON DELETE CASCADE,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    
    -- Queue management
    position INTEGER NOT NULL,
    priority_score INTEGER DEFAULT 0,
    
    -- Status tracking
    status VARCHAR(50) NOT NULL DEFAULT 'waiting',
    joined_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    promoted_at TIMESTAMP,
    notified_at TIMESTAMP,
    
    -- Metadata
    notes TEXT,
    auto_accept BOOLEAN DEFAULT FALSE,
    
    -- Constraints
    UNIQUE(shift_id, volunteer_id),
    CHECK (position > 0)
);

-- Volunteer Availability Tracking
CREATE TABLE volunteer_availability (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id) ON DELETE CASCADE,
    
    -- Date range
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    
    -- Time of day (optional)
    start_time TIME,
    end_time TIME,
    
    -- Recurrence pattern for recurring availability
    recurrence_pattern JSONB,
    
    -- Type
    availability_type VARCHAR(50) DEFAULT 'general',
    event_id INTEGER REFERENCES events(id) ON DELETE CASCADE,
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CHECK (start_date <= end_date),
    CHECK (start_time IS NULL OR end_time IS NULL OR start_time < end_time)
);

-- Shift Swap Requests
CREATE TABLE shift_swap_requests (
    id SERIAL PRIMARY KEY,
    
    -- Original assignment
    original_assignment_id INTEGER NOT NULL REFERENCES event_assignments(id),
    requesting_volunteer_id INTEGER NOT NULL REFERENCES volunteers(id),
    
    -- Target volunteer (optional)
    target_volunteer_id INTEGER REFERENCES volunteers(id),
    
    -- Status
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    
    -- Approval workflow
    approved_by INTEGER REFERENCES users(id),
    approved_at TIMESTAMP,
    rejection_reason TEXT,
    
    -- Metadata
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Enhanced Shifts Table
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS template_id INTEGER REFERENCES shift_templates(id);
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS allow_self_signup BOOLEAN DEFAULT FALSE;
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS enable_waitlist BOOLEAN DEFAULT TRUE;
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS waitlist_capacity INTEGER DEFAULT 10;
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS required_skills JSONB;
ALTER TABLE shifts ADD COLUMN IF NOT EXISTS conflict_detection BOOLEAN DEFAULT TRUE;

-- Indexes
CREATE INDEX idx_shift_templates_tenant ON shift_templates(tenant_id);
CREATE INDEX idx_shift_waitlists_shift ON shift_waitlists(shift_id, position);
CREATE INDEX idx_shift_waitlists_volunteer ON shift_waitlists(volunteer_id);
CREATE INDEX idx_volunteer_availability_dates ON volunteer_availability(volunteer_id, start_date, end_date);
CREATE INDEX idx_shift_swap_status ON shift_swap_requests(status, created_at);

-- Update existing shifts to have sensible defaults
UPDATE shifts SET 
    allow_self_signup = FALSE,
    enable_waitlist = TRUE,
    waitlist_capacity = 10,
    conflict_detection = TRUE
WHERE allow_self_signup IS NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_shifts_self_signup ON shifts(allow_self_signup) WHERE allow_self_signup = TRUE;
CREATE INDEX IF NOT EXISTS idx_shifts_template ON shifts(template_id);

COMMENT ON COLUMN shifts.allow_self_signup IS 'Whether volunteers can self-signup for this shift';
COMMENT ON COLUMN shifts.enable_waitlist IS 'Whether to enable waitlist when shift is full';
COMMENT ON COLUMN shifts.waitlist_capacity IS 'Maximum number of volunteers on waitlist';
COMMENT ON COLUMN shifts.required_skills IS 'JSON array of required skills';
COMMENT ON COLUMN shifts.conflict_detection IS 'Whether to prevent double-booking';

-- Grant permissions
GRANT ALL PRIVILEGES ON shift_templates TO vvhs;
GRANT ALL PRIVILEGES ON shift_waitlists TO vvhs;
GRANT ALL PRIVILEGES ON volunteer_availability TO vvhs;
GRANT ALL PRIVILEGES ON shift_swap_requests TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;

-- Sample shift template data (2x more)
INSERT INTO shift_templates (tenant_id, name, description, recurrence_pattern, duration_minutes, max_volunteers, allow_self_signup, enable_waitlist, created_by) VALUES
(1, 'Weekly Vaccine Clinic - Morning', 'Standard morning vaccine clinic shift', 
 '{"frequency": "weekly", "days": [2, 4], "interval": 1}'::jsonb, 
 240, 10, true, true, 1),
(1, 'Weekly Vaccine Clinic - Afternoon', 'Standard afternoon vaccine clinic shift',
 '{"frequency": "weekly", "days": [2, 4], "interval": 1}'::jsonb,
 240, 8, true, true, 1),
(1, 'Weekend Emergency Response', 'Weekend on-call emergency response', 
 '{"frequency": "weekly", "days": [6, 0], "interval": 1}'::jsonb, 
 480, 5, false, true, 1),
(1, 'Monthly Training Session', 'Monthly volunteer training and updates',
 '{"frequency": "monthly", "interval": 1, "day_of_month": 15}'::jsonb,
 180, 30, false, false, 1);

-- Sample volunteer availability (for active volunteers)
INSERT INTO volunteer_availability (volunteer_id, start_date, end_date, availability_type, notes) VALUES
(1, '2025-11-01', '2025-12-31', 'general', 'Available weekends and evenings'),
(2, '2025-11-01', '2025-12-31', 'general', 'Flexible schedule'),
(3, '2025-11-01', '2025-12-31', 'general', 'Weekday evenings after 5pm'),
(4, '2025-11-15', '2025-12-31', 'general', 'Available most weekdays'),
(5, '2025-11-01', '2025-12-31', 'general', 'Weekend preferred'),
(7, '2025-11-01', '2025-12-31', 'general', 'Flexible, prefer weekdays'),
(8, '2025-11-01', '2025-12-31', 'general', 'Night shifts and weekends'),
(9, '2025-11-01', '2025-12-31', 'general', 'Weekday evenings only');

-- Sample waitlist entries (for full shifts)
INSERT INTO shift_waitlists (shift_id, volunteer_id, position, status, notes) VALUES
(1, 6, 1, 'waiting', 'Interested in morning shift'),
(1, 9, 2, 'waiting', 'Can provide pharmaceutical support'),
(2, 10, 1, 'waiting', 'Available for learning experience');

COMMENT ON TABLE shift_templates IS 'Templates for creating recurring shifts';
COMMENT ON TABLE shift_waitlists IS 'Waitlist queue for fully-booked shifts';
COMMENT ON TABLE volunteer_availability IS 'Volunteer availability calendar and preferences';
COMMENT ON TABLE shift_swap_requests IS 'Volunteer-initiated shift swap requests';

-- populates shift sign up page, non-tennanted
UPDATE shifts SET allow_self_signup = TRUE WHERE allow_self_signup = FALSE;======================================

======================================
File: 01_init.sql
Path: ./api/db_init
--------------------------------------
-- VVHS Database Enhanced Schema
-- Comprehensive volunteer management system with all necessary fields

-- Drop all existing tables to start fresh
DROP TABLE IF EXISTS audit_logs CASCADE;
DROP TABLE IF EXISTS event_assignments CASCADE;
DROP TABLE IF EXISTS shifts CASCADE;
DROP TABLE IF EXISTS events CASCADE;
DROP TABLE IF EXISTS training_records CASCADE;
DROP TABLE IF EXISTS volunteers CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS tenants CASCADE;

-- Create tenants table (organizations/health districts)
CREATE TABLE tenants (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    slug VARCHAR(100) NOT NULL UNIQUE,
    contact_email VARCHAR(255) NOT NULL,
    contact_phone VARCHAR(20),
    address_line1 VARCHAR(255),
    address_line2 VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(2) DEFAULT 'VA',
    zip_code VARCHAR(10),
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    settings TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create users table (staff and administrators)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id),
    
    -- Authentication
    username VARCHAR(100) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    hashed_password VARCHAR(255) NOT NULL,
    
    -- Profile
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    
    -- Role and permissions
    role VARCHAR(50) NOT NULL DEFAULT 'sub_unit_staff',
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    
    -- Sub-unit staff permissions
    can_view_data BOOLEAN DEFAULT TRUE,
    can_edit_data BOOLEAN DEFAULT FALSE,
    can_send_password_reminder BOOLEAN DEFAULT FALSE,
    can_initiate_transfers BOOLEAN DEFAULT FALSE,
    can_approve_transfers BOOLEAN DEFAULT FALSE,
    can_view_alerts BOOLEAN DEFAULT TRUE,
    can_edit_alerts BOOLEAN DEFAULT FALSE,
    can_export_data BOOLEAN DEFAULT FALSE,
    
    -- Multi-factor authentication
    mfa_enabled BOOLEAN DEFAULT FALSE,
    mfa_secret VARCHAR(255),
    
    -- Timestamps
    last_login TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create enhanced volunteers table with all necessary fields
CREATE TABLE volunteers (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id),
    
    -- Authentication (for volunteer portal)
    username VARCHAR(100) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL,
    hashed_password VARCHAR(255),
    
    -- Personal Information
    first_name VARCHAR(100) NOT NULL,
    middle_name VARCHAR(100),
    last_name VARCHAR(100) NOT NULL,
    date_of_birth DATE,
    
    -- Contact Information
    phone_primary VARCHAR(20),
    phone_secondary VARCHAR(20),
    address_line1 VARCHAR(255),
    address_line2 VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(2) DEFAULT 'VA',
    zip_code VARCHAR(10),
    
    -- Emergency Contact
    emergency_contact_name VARCHAR(255),
    emergency_contact_phone VARCHAR(20),
    emergency_contact_relationship VARCHAR(100),
    
    -- Application Status
    application_status VARCHAR(20) DEFAULT 'pending',
    account_status VARCHAR(20) DEFAULT 'active',
    mrc_level VARCHAR(20),
    
    -- Professional Information
    occupation VARCHAR(100),
    employer VARCHAR(255),
    professional_skills TEXT,  -- Enhanced from just 'skills'
    license_number VARCHAR(100),
    license_type VARCHAR(100),
    license_state VARCHAR(2),
    license_expiration DATE,
    
    -- Skills and Languages
    skills TEXT,  -- General skills
    languages VARCHAR(255),
    
    -- Training and Credentials
    certifications TEXT,
    certification_info TEXT,  -- Additional certification details
    train_id VARCHAR(100),
    train_data TEXT,
    
    -- Availability and Preferences
    availability TEXT,
    availability_info TEXT,  -- Additional availability details
    travel_distance INTEGER DEFAULT 25,
    preferred_roles TEXT,
    assigned_groups TEXT,
    assigned_roles TEXT,
    
    -- Metrics and Performance
    total_hours DECIMAL(10,2) DEFAULT 0,
    alert_response_rate DECIMAL(5,2) DEFAULT 0,
    badges_earned TEXT,
    
    -- Background Check
    background_check_date DATE,
    background_check_status VARCHAR(20),
    
    -- Important Dates
    application_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approval_date TIMESTAMP,
    last_activity_date TIMESTAMP,
    
    -- System Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_activity TIMESTAMP,  -- Keeping for backward compatibility
    approved_at TIMESTAMP,     -- Keeping for backward compatibility
    approved_by INTEGER REFERENCES users(id)
);

-- Create events table
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL REFERENCES tenants(id),
    
    -- Basic Information
    name VARCHAR(255) NOT NULL,
    title VARCHAR(255),  -- Adding title for display
    staff_description TEXT,
    volunteer_description TEXT,
    location VARCHAR(255),
    locality VARCHAR(100),
    
    -- Dates and Times
    event_date TIMESTAMP,  -- Primary event date
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP,
    
    -- Event Classification
    activity_type VARCHAR(50) NOT NULL,
    response_name VARCHAR(255),
    mission_types TEXT,
    requestor_type VARCHAR(100),
    
    -- Volunteer Requirements
    max_volunteers INTEGER DEFAULT 100,
    min_volunteers INTEGER DEFAULT 1,
    registered_volunteers INTEGER DEFAULT 0,
    
    -- Visibility and Configuration
    visible_to_volunteers BOOLEAN DEFAULT TRUE,
    allow_self_signup BOOLEAN DEFAULT FALSE,
    enable_waitlist BOOLEAN DEFAULT FALSE,
    districts TEXT,
    
    -- Status
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    
    -- Impact Tracking
    impact_data TEXT,
    
    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id)
);

-- Create shifts table
CREATE TABLE shifts (
    id SERIAL PRIMARY KEY,
    event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,
    
    name VARCHAR(255) NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    max_volunteers INTEGER,
    min_volunteers INTEGER DEFAULT 1,
    
    required_skills TEXT,
    description TEXT,
    location VARCHAR(255),
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create enhanced event_assignments table
CREATE TABLE event_assignments (
    id SERIAL PRIMARY KEY,
    event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id),
    shift_id INTEGER REFERENCES shifts(id),
    
    -- Status and Tracking
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    hours_completed DECIMAL(5,2),
    hours_served DECIMAL(5,2),  -- Additional field
    
    -- Check-in/Check-out
    check_in_time TIMESTAMP,
    check_out_time TIMESTAMP,
    
    -- Notes
    notes TEXT,
    coordinator_notes TEXT,
    volunteer_notes TEXT,
    
    -- Timestamps
    assigned_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    assigned_by INTEGER REFERENCES users(id),
    confirmed_at TIMESTAMP,
    completed_at TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(event_id, volunteer_id, shift_id)
);

-- Create training_records table
CREATE TABLE training_records (
    id SERIAL PRIMARY KEY,
    volunteer_id INTEGER NOT NULL REFERENCES volunteers(id),
    course_name VARCHAR(255) NOT NULL,
    course_type VARCHAR(100),
    provider VARCHAR(255),
    completion_date DATE NOT NULL,
    expiration_date DATE,
    certificate_number VARCHAR(100),
    credits_earned DECIMAL(5,2),
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create audit_logs table
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    tenant_id INTEGER NOT NULL,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id INTEGER,
    ip_address VARCHAR(45),
    user_agent VARCHAR(255),
    endpoint VARCHAR(255),
    http_method VARCHAR(10),
    old_values JSON,
    new_values JSON,
    description TEXT,
    status VARCHAR(20),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_volunteers_tenant_id ON volunteers(tenant_id);
CREATE INDEX idx_volunteers_email ON volunteers(email);
CREATE INDEX idx_volunteers_application_status ON volunteers(application_status);
CREATE INDEX idx_events_tenant_id ON events(tenant_id);
CREATE INDEX idx_events_start_date ON events(start_date);
CREATE INDEX idx_event_assignments_volunteer_id ON event_assignments(volunteer_id);
CREATE INDEX idx_event_assignments_event_id ON event_assignments(event_id);
CREATE INDEX idx_training_records_volunteer_id ON training_records(volunteer_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_tenant_id ON audit_logs(tenant_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);

-- =====================================
-- INSERT ENHANCED DUMMY DATA
-- =====================================

-- Insert tenants (health districts/organizations)
INSERT INTO tenants (id, name, slug, contact_email, contact_phone, address_line1, city, state, zip_code, is_active) VALUES
(1, 'Virginia Department of Health', 'vdh', 'admin@vdh.virginia.gov', '804-864-7001', '109 Governor Street', 'Richmond', 'VA', '23219', true),
(2, 'Richmond MRC', 'richmond-mrc', 'coordinator@richmond-mrc.org', '804-205-3501', '400 E Cary St', 'Richmond', 'VA', '23219', true),
(3, 'Fairfax County MRC', 'fairfax-mrc', 'info@fairfax-mrc.org', '703-246-2411', '10777 Main St', 'Fairfax', 'VA', '22030', true),
(4, 'Norfolk Health District', 'norfolk-hd', 'contact@norfolk-hd.org', '757-683-2745', '830 Southampton Ave', 'Norfolk', 'VA', '23510', true);

-- Insert users (password for all: 't3st45#!$6!')
INSERT INTO users (
    tenant_id, username, email, hashed_password,
    first_name, last_name, phone, role, status,
    can_view_data, can_edit_data, can_export_data, can_send_password_reminder
) VALUES
-- System Admins
(1, 'admin@vdh.virginia.gov', 'admin@vdh.virginia.gov', 
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Sarah', 'Johnson', '804-864-7001', 'system_admin', 'active',
 true, true, true, true),

(1, 'mike.wilson@vdh.virginia.gov', 'mike.wilson@vdh.virginia.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Mike', 'Wilson', '804-864-7002', 'system_admin', 'active',
 true, true, true, true),

-- Organization Admins
(1, 'laura.martinez@vdh.virginia.gov', 'laura.martinez@vdh.virginia.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Laura', 'Martinez', '804-864-7003', 'org_admin', 'active',
 true, true, true, false),

(2, 'coordinator@richmond-mrc.org', 'coordinator@richmond-mrc.org',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Emily', 'Rodriguez', '804-205-3502', 'org_admin', 'active',
 true, true, true, false);

-- Insert comprehensive volunteer data for TENANT 1 (VDH) - 10 volunteers
INSERT INTO volunteers (
    tenant_id, username, email, hashed_password,
    first_name, middle_name, last_name, date_of_birth,
    phone_primary, phone_secondary, address_line1, city, state, zip_code,
    emergency_contact_name, emergency_contact_phone, emergency_contact_relationship,
    application_status, account_status, mrc_level,
    occupation, employer, professional_skills, skills, languages,
    license_number, license_type, license_state, license_expiration,
    certifications, train_id, availability, travel_distance,
    total_hours, alert_response_rate, badges_earned,
    background_check_date, background_check_status,
    application_date, approval_date, last_activity_date
) VALUES
-- Volunteer 1: Alice Anderson (RN)
(1, 'alice.anderson@vdh.gov', 'alice.anderson@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Alice', 'Marie', 'Anderson', '1985-03-15',
 '804-555-0001', '804-555-0002', '123 Main St', 'Richmond', 'VA', '23220',
 'Bob Anderson', '804-555-0003', 'Spouse',
 'approved', 'active', 'level_2',
 'Registered Nurse', 'VCU Health', 'Emergency Medicine, Critical Care, Pediatrics',
 'Medical Care, CPR, First Aid, Triage, IV Therapy', 'English, Spanish',
 'RN123456', 'RN', 'VA', '2026-12-31',
 'RN License, CPR, BLS, ACLS, PALS', 'TRAIN100001', 'Weekends, Evenings, On-call', 50,
 245.5, 92.5, 'Leadership, 100 Hours, First Responder',
 '2024-01-15', 'cleared',
 '2024-01-01 09:00:00', '2024-01-20 14:30:00', '2025-11-06 10:00:00'),

-- Volunteer 2: Bob Brown (EMT)
(1, 'bob.brown@vdh.gov', 'bob.brown@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Bob', NULL, 'Brown', '1990-07-22',
 '804-555-0004', NULL, '456 Oak Ave', 'Norfolk', 'VA', '23510',
 'Jane Brown', '804-555-0005', 'Wife',
 'approved', 'active', 'level_1',
 'EMT', 'Norfolk Fire Department', 'Emergency Response, Firefighting',
 'Emergency Medical Services, Hazmat Response', 'English',
 'EMT789012', 'EMT-B', 'VA', '2025-06-30',
 'EMT-B, CPR, Hazmat Operations', 'TRAIN100002', 'Flexible', 75,
 98.0, 85.0, 'Fast Responder',
 '2024-11-01', 'cleared',
 '2024-10-15 10:00:00', '2024-10-25 14:00:00', '2025-11-05 08:00:00'),

-- Volunteer 3: Carol Clark (MD)
(1, 'carol.clark@vdh.gov', 'carol.clark@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Carol', 'Anne', 'Clark', '1988-11-08',
 '703-555-0006', '703-555-0007', '789 Pine Rd', 'Fairfax', 'VA', '22030',
 'David Clark', '703-555-0008', 'Brother',
 'approved', 'active', 'level_3',
 'Physician', 'Inova Health', 'Internal Medicine, Infectious Disease',
 'Medical Care, Vaccination, Disease Surveillance', 'English, French, Arabic',
 'MD456789', 'MD', 'VA', '2027-12-31',
 'MD License, Board Certified IM, CPR, ACLS', 'TRAIN100003', 'Weekdays after 5pm, Weekends', 30,
 189.0, 88.0, 'Medical Expert, COVID Response Hero',
 '2024-02-10', 'cleared',
 '2024-02-01 11:00:00', '2024-02-15 09:00:00', '2025-11-05 15:30:00'),

-- Volunteer 4: David Davis (Paramedic)
(1, 'david.davis@vdh.gov', 'david.davis@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'David', 'Lee', 'Davis', '1982-05-20',
 '804-555-0010', '804-555-0011', '321 Elm St', 'Richmond', 'VA', '23221',
 'Susan Davis', '804-555-0012', 'Sister',
 'approved', 'active', 'level_2',
 'Paramedic', 'Richmond Ambulance', 'Advanced Life Support, Trauma',
 'ALS, Trauma Care, Patient Transport', 'English',
 'PM345678', 'Paramedic', 'VA', '2026-08-15',
 'Paramedic, ACLS, PALS, ITLS', 'TRAIN100004', 'Weekdays, Some weekends', 40,
 312.0, 94.0, 'Excellence Award, 300+ Hours',
 '2024-03-01', 'cleared',
 '2024-02-20 08:00:00', '2024-03-10 16:00:00', '2025-11-06 14:00:00'),

-- Volunteer 5: Emma Evans (RN)
(1, 'emma.evans@vdh.gov', 'emma.evans@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Emma', 'Grace', 'Evans', '1992-09-12',
 '804-555-0013', NULL, '654 Birch Ln', 'Richmond', 'VA', '23222',
 'Tom Evans', '804-555-0014', 'Father',
 'approved', 'active', 'level_2',
 'Registered Nurse', 'Bon Secours', 'Pediatric Care, Vaccination',
 'Pediatric Nursing, Vaccine Administration', 'English, Mandarin',
 'RN234567', 'RN', 'VA', '2026-11-30',
 'RN License, CPR, BLS, Pediatric Advanced Life Support', 'TRAIN100005', 'Weekends preferred', 35,
 167.5, 90.0, '150 Hours, Community Champion',
 '2024-04-05', 'cleared',
 '2024-03-25 10:00:00', '2024-04-12 11:00:00', '2025-11-04 09:00:00'),

-- Volunteer 6: Frank Foster (EMT)
(1, 'frank.foster@vdh.gov', 'frank.foster@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Frank', NULL, 'Foster', '1987-12-03',
 '757-555-0015', '757-555-0016', '987 Cedar Dr', 'Norfolk', 'VA', '23511',
 'Linda Foster', '757-555-0017', 'Mother',
 'approved', 'active', 'level_1',
 'EMT', 'Virginia Beach EMS', 'Emergency Medical Services',
 'EMT, CPR, Emergency Response', 'English',
 'EMT456789', 'EMT-B', 'VA', '2026-03-20',
 'EMT-B, CPR, First Responder', 'TRAIN100006', 'Evenings and weekends', 60,
 145.0, 87.0, 'Dedicated Volunteer',
 '2024-05-10', 'cleared',
 '2024-04-28 09:00:00', '2024-05-18 15:00:00', '2025-11-03 11:00:00'),

-- Volunteer 7: Grace Garcia (PA)
(1, 'grace.garcia@vdh.gov', 'grace.garcia@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Grace', 'Maria', 'Garcia', '1989-06-18',
 '804-555-0018', '804-555-0019', '147 Maple Ave', 'Richmond', 'VA', '23223',
 'Carlos Garcia', '804-555-0020', 'Husband',
 'approved', 'active', 'level_3',
 'Physician Assistant', 'VCU Medical Center', 'Family Medicine, Urgent Care',
 'Primary Care, Diagnostics, Patient Assessment', 'English, Spanish',
 'PA567890', 'PA-C', 'VA', '2027-07-15',
 'PA License, CPR, BLS, ACLS', 'TRAIN100007', 'Flexible schedule', 45,
 223.5, 91.5, 'Medical Professional, Bilingual Services',
 '2024-06-01', 'cleared',
 '2024-05-20 08:30:00', '2024-06-10 13:00:00', '2025-11-06 16:00:00'),

-- Volunteer 8: Henry Harris (RN)
(1, 'henry.harris@vdh.gov', 'henry.harris@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Henry', 'James', 'Harris', '1984-04-25',
 '804-555-0021', NULL, '258 Walnut St', 'Richmond', 'VA', '23224',
 'Mary Harris', '804-555-0022', 'Wife',
 'approved', 'active', 'level_2',
 'Registered Nurse', 'Chippenham Hospital', 'ICU, Critical Care',
 'Critical Care Nursing, Ventilator Management', 'English',
 'RN345678', 'RN', 'VA', '2027-01-31',
 'RN License, CPR, BLS, ACLS, CCRN', 'TRAIN100008', 'Night shifts, Weekends', 50,
 201.0, 89.0, 'ICU Specialist, Night Shift Hero',
 '2024-07-01', 'cleared',
 '2024-06-15 10:00:00', '2024-07-08 14:00:00', '2025-11-05 19:00:00'),

-- Volunteer 9: Isabel Ingram (Pharmacist)
(1, 'isabel.ingram@vdh.gov', 'isabel.ingram@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Isabel', 'Rose', 'Ingram', '1991-08-30',
 '804-555-0023', '804-555-0024', '369 Spruce Rd', 'Richmond', 'VA', '23225',
 'Paul Ingram', '804-555-0025', 'Brother',
 'approved', 'active', 'level_2',
 'Pharmacist', 'CVS Pharmacy', 'Medication Management, Immunization',
 'Pharmaceutical Care, Vaccine Administration, Patient Counseling', 'English, Korean',
 'RPH678901', 'PharmD', 'VA', '2027-09-30',
 'Pharmacist License, CPR, Immunization Certified', 'TRAIN100009', 'Weekday evenings', 30,
 134.0, 86.5, 'Vaccine Expert',
 '2024-08-05', 'cleared',
 '2024-07-22 11:00:00', '2024-08-15 10:00:00', '2025-11-04 13:00:00'),

-- Volunteer 10: Jack Jackson (Student)
(1, 'jack.jackson@vdh.gov', 'jack.jackson@vdh.gov',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Jack', 'Ryan', 'Jackson', '1998-11-14',
 '804-555-0026', NULL, '741 Poplar Ct', 'Richmond', 'VA', '23226',
 'Rachel Jackson', '804-555-0027', 'Mother',
 'approved', 'active', 'level_1',
 'Nursing Student', 'VCU School of Nursing', 'Student Clinical Experience',
 'Basic Nursing Skills, Vital Signs, Patient Care', 'English',
 NULL, 'Student', 'VA', NULL,
 'CPR, BLS, Student Nurse', 'TRAIN100010', 'Weekends and school breaks', 25,
 67.5, 92.0, 'Rising Star',
 '2024-09-01', 'cleared',
 '2024-08-20 09:00:00', '2024-09-05 12:00:00', '2025-11-02 10:00:00');


-- Richmond MRC Volunteers (tenant_id = 2) - Keep existing 2
INSERT INTO volunteers (
    tenant_id, username, email, hashed_password,
    first_name, middle_name, last_name, date_of_birth,
    phone_primary, phone_secondary, address_line1, city, state, zip_code,
    emergency_contact_name, emergency_contact_phone, emergency_contact_relationship,
    application_status, account_status, mrc_level,
    occupation, employer, professional_skills, skills, languages,
    license_number, license_type, license_state, license_expiration,
    certifications, train_id, availability, travel_distance,
    total_hours, alert_response_rate, badges_earned,
    background_check_date, background_check_status,
    application_date, approval_date, last_activity_date
) VALUES
(2, 'jane.doe@email.com', 'jane.doe@email.com',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'Jane', 'Marie', 'Doe', '1985-03-15',
 '804-555-1111', '804-555-1112', '123 Main St', 'Richmond', 'VA', '23220',
 'John Doe', '804-555-1110', 'Spouse',
 'approved', 'active', 'level_2',
 'Registered Nurse', 'VCU Health', 'Critical Care, Emergency Medicine',
 'Medical Care, CPR, First Aid, Triage', 'English, Spanish',
 'RN654321', 'RN', 'VA', '2025-12-31',
 'RN License, CPR, BLS', 'TRAIN123456', 'Weekends, Evenings', 25,
 156.5, 95.0, 'Dedicated Volunteer, Team Leader',
 '2024-06-01', 'cleared',
 '2024-05-15 08:00:00', '2024-06-05 10:00:00', '2025-11-04 12:00:00'),

(2, 'john.smith@email.com', 'john.smith@email.com',
 '$2b$12$EImfq5A648cjQzk5djSQxeYO5a/Tic/KWOyVnJdXKkpuCBK/kTGFq',
 'John', 'Robert', 'Smith', '1978-07-22',
 '804-555-2222', NULL, '456 Oak Ave', 'Richmond', 'VA', '23221',
 'Sarah Smith', '804-555-2223', 'Wife',
 'approved', 'active', 'level_3',
 'Paramedic', 'Richmond Ambulance Authority', 'Advanced Life Support, Trauma Care',
 'Emergency Medical Services, Leadership, Logistics', 'English',
 'PM987654', 'Paramedic', 'VA', '2026-06-30',
 'Paramedic, ACLS, PALS', 'TRAIN789012', 'Flexible', 50,
 312.0, 91.5, 'Excellence Award, 300 Hour Club',
 '2024-05-15', 'cleared',
 '2024-05-01 09:30:00', '2024-05-20 14:00:00', '2025-11-06 08:00:00');

-- Insert events for TENANT 1 (VDH) - 6 events (2x)
INSERT INTO events (
    tenant_id, name, title, staff_description, volunteer_description,
    location, locality, event_date, start_date, end_date,
    activity_type, response_name, mission_types,
    max_volunteers, registered_volunteers,
    visible_to_volunteers, allow_self_signup, status, created_by
) VALUES
(1, 'COVID-19 Vaccination Clinic - Richmond Convention Center', 'Mass Vaccination Event',
 'Large-scale vaccination event requiring medical and support volunteers',
 'Help provide COVID-19 vaccinations to the community. Various roles available.',
 'Richmond Convention Center', 'Richmond',
 '2025-11-20 08:00:00', '2025-11-20 08:00:00', '2025-11-20 17:00:00',
 'vaccination', 'COVID-19 Response', '["Medical Care", "Logistics", "Public Health"]',
 50, 15, true, true, 'published', 1),

(1, 'Emergency Preparedness Training - Fall 2025', 'Quarterly MRC Training',
 'Essential training for all MRC volunteers covering emergency response protocols',
 'Learn emergency response protocols and procedures. Mandatory for all active volunteers.',
 'VDH Training Center', 'Richmond',
 '2025-12-05 09:00:00', '2025-12-05 09:00:00', '2025-12-05 16:00:00',
 'training', 'Training Event', '["Training", "Emergency Response"]',
 30, 12, true, false, 'published', 1),

(1, 'Flu Vaccination Clinic - West End', 'Community Flu Shots',
 'Seasonal flu vaccination clinic for underserved communities',
 'Help administer flu vaccines to community members. Medical and non-medical roles available.',
 'West End Community Center', 'Richmond',
 '2025-11-25 10:00:00', '2025-11-25 10:00:00', '2025-11-25 15:00:00',
 'vaccination', 'Seasonal Flu Campaign', '["Medical Care", "Public Health"]',
 25, 8, true, true, 'published', 1),

(1, 'Disaster Preparedness Fair - Richmond', 'Public Health Education Event',
 'Community outreach event to educate public about disaster preparedness',
 'Help staff booths and educate the public about emergency preparedness.',
 'Richmond Fairgrounds', 'Richmond',
 '2025-12-10 11:00:00', '2025-12-10 11:00:00', '2025-12-10 16:00:00',
 'education', 'Community Outreach', '["Education", "Public Awareness"]',
 20, 6, true, true, 'published', 1),

(1, 'COVID-19 Booster Clinic - Southside', 'Booster Vaccination Event',
 'COVID-19 booster shots for eligible community members',
 'Assist with COVID-19 booster vaccinations. Medical and administrative roles needed.',
 'Southside Health Center', 'Richmond',
 '2025-12-15 09:00:00', '2025-12-15 09:00:00', '2025-12-15 14:00:00',
 'vaccination', 'COVID-19 Response', '["Medical Care", "Vaccination"]',
 30, 10, true, true, 'published', 1),

(1, 'Winter Emergency Response Training', 'Cold Weather Emergency Prep',
 'Specialized training for winter emergency response scenarios',
 'Learn cold weather emergency response procedures and hypothermia treatment.',
 'VDH Regional Office', 'Richmond',
 '2025-12-18 13:00:00', '2025-12-18 13:00:00', '2025-12-18 17:00:00',
 'training', 'Winter Preparedness', '["Training", "Emergency Response"]',
 25, 7, true, false, 'published', 1);

-- Insert shifts for events (create 2 shifts per event for events 1, 3, and 5)
INSERT INTO shifts (event_id, name, start_time, end_time, max_volunteers, min_volunteers, description, location) VALUES
-- Event 1 shifts (Convention Center Vaccination)
(1, 'Morning Vaccination Team', '2025-11-20 08:00:00', '2025-11-20 12:00:00', 25, 10, 'Morning shift - setup and initial vaccination wave', 'Richmond Convention Center'),
(1, 'Afternoon Vaccination Team', '2025-11-20 12:00:00', '2025-11-20 17:00:00', 25, 10, 'Afternoon shift - peak hours and cleanup', 'Richmond Convention Center'),

-- Event 3 shifts (West End Flu Clinic)
(3, 'Setup and Morning Shift', '2025-11-25 10:00:00', '2025-11-25 12:30:00', 12, 5, 'Setup and morning vaccination session', 'West End Community Center'),
(3, 'Afternoon Shift', '2025-11-25 12:30:00', '2025-11-25 15:00:00', 13, 5, 'Afternoon session and cleanup', 'West End Community Center'),

-- Event 5 shifts (Southside Booster Clinic)
(5, 'Morning Booster Team', '2025-12-15 09:00:00', '2025-12-15 11:30:00', 15, 7, 'Morning booster administration', 'Southside Health Center'),
(5, 'Afternoon Booster Team', '2025-12-15 11:30:00', '2025-12-15 14:00:00', 15, 7, 'Afternoon booster administration', 'Southside Health Center');

-- Insert event assignments (more assignments for events)
INSERT INTO event_assignments (
    event_id, volunteer_id, shift_id, status,
    hours_completed, hours_served,
    coordinator_notes, assigned_by, assigned_at, confirmed_at
) VALUES
-- Event 1 assignments
(1, 1, 1, 'confirmed', 4.0, 4.0, 'Team leader for vaccination station', 1, '2025-11-01 10:00:00', '2025-11-02 09:00:00'),
(1, 3, 1, 'confirmed', 4.0, 4.0, 'Medical screening and vaccination', 1, '2025-11-01 10:30:00', '2025-11-02 09:30:00'),
(1, 4, 2, 'confirmed', 5.0, 5.0, 'Lead paramedic, afternoon shift', 1, '2025-11-01 11:00:00', '2025-11-02 10:00:00'),
(1, 5, 2, 'confirmed', 5.0, 5.0, 'Pediatric vaccination specialist', 1, '2025-11-01 11:30:00', '2025-11-02 10:30:00'),
(1, 7, 1, 'confirmed', 4.0, 4.0, 'Patient assessment and triage', 1, '2025-11-01 12:00:00', '2025-11-02 11:00:00'),

-- Event 2 assignments (Training)
(2, 1, NULL, 'confirmed', 7.0, 7.0, 'Training instructor', 1, '2025-11-15 14:00:00', '2025-11-16 08:00:00'),
(2, 4, NULL, 'confirmed', 7.0, 7.0, 'Training assistant', 1, '2025-11-15 14:15:00', '2025-11-16 08:15:00'),
(2, 8, NULL, 'pending', NULL, NULL, 'Requested participation', 1, '2025-11-15 14:30:00', NULL),

-- Event 3 assignments
(3, 2, 3, 'confirmed', 2.5, 2.5, 'Setup and registration', 1, '2025-11-10 09:00:00', '2025-11-11 10:00:00'),
(3, 6, 4, 'confirmed', 2.5, 2.5, 'Flu vaccination administrator', 1, '2025-11-10 09:30:00', '2025-11-11 10:30:00'),
(3, 9, 3, 'confirmed', 2.5, 2.5, 'Pharmaceutical oversight', 1, '2025-11-10 10:00:00', '2025-11-11 11:00:00'),

-- Event 4 assignments
(4, 5, NULL, 'confirmed', 5.0, 5.0, 'Education booth coordinator', 1, '2025-11-18 10:00:00', '2025-11-19 09:00:00'),
(4, 10, NULL, 'confirmed', 5.0, 5.0, 'Volunteer assistant', 1, '2025-11-18 10:30:00', '2025-11-19 09:30:00'),

-- Event 5 assignments
(5, 1, 5, 'pending', NULL, NULL, 'Lead nurse requested', 1, '2025-11-20 11:00:00', NULL),
(5, 3, 6, 'pending', NULL, NULL, 'Physician requested', 1, '2025-11-20 11:15:00', NULL),
(5, 7, 5, 'confirmed', 2.5, 2.5, 'PA confirmed for morning', 1, '2025-11-20 11:30:00', '2025-11-21 08:00:00');

-- Insert training records (2x more training records)
INSERT INTO training_records (
    volunteer_id, course_name, course_type, provider,
    completion_date, expiration_date, certificate_number, credits_earned
) VALUES
-- Alice Anderson (volunteer 1)
(1, 'Advanced Cardiac Life Support', 'Certification', 'American Heart Association', 
 '2024-03-15', '2026-03-15', 'ACLS-2024-001', 8.0),
(1, 'Pediatric Advanced Life Support', 'Certification', 'American Heart Association',
 '2024-04-20', '2026-04-20', 'PALS-2024-001', 8.0),
(1, 'Trauma Nursing Core Course', 'Certification', 'Emergency Nurses Association',
 '2024-05-10', '2028-05-10', 'TNCC-2024-001', 16.0),

-- Carol Clark (volunteer 3)
(3, 'Incident Command System 100', 'Training', 'FEMA',
 '2024-05-10', NULL, 'ICS100-2024-003', 4.0),
(3, 'Incident Command System 200', 'Training', 'FEMA',
 '2024-06-01', NULL, 'ICS200-2024-003', 8.0),
(3, 'Disaster Medicine', 'Training', 'NDMS',
 '2024-07-15', NULL, 'DM-2024-003', 12.0),

-- David Davis (volunteer 4)
(4, 'Advanced Cardiac Life Support', 'Certification', 'American Heart Association',
 '2024-02-10', '2026-02-10', 'ACLS-2024-004', 8.0),
(4, 'Pediatric Advanced Life Support', 'Certification', 'American Heart Association',
 '2024-03-05', '2026-03-05', 'PALS-2024-004', 8.0),
(4, 'International Trauma Life Support', 'Certification', 'ITLS',
 '2024-04-18', '2027-04-18', 'ITLS-2024-004', 16.0),

-- Emma Evans (volunteer 5)
(5, 'Basic Life Support Provider', 'Certification', 'American Red Cross',
 '2024-06-01', '2026-06-01', 'BLS-2024-005', 4.0),
(5, 'Pediatric Advanced Life Support', 'Certification', 'American Heart Association',
 '2024-07-10', '2026-07-10', 'PALS-2024-005', 8.0),

-- Frank Foster (volunteer 6)
(6, 'CPR for Healthcare Providers', 'Certification', 'American Heart Association',
 '2024-08-05', '2026-08-05', 'CPR-2024-006', 4.0),
(6, 'Emergency Vehicle Operations', 'Training', 'Virginia EMS',
 '2024-09-12', '2027-09-12', 'EVO-2024-006', 8.0),

-- Grace Garcia (volunteer 7)
(7, 'Advanced Cardiac Life Support', 'Certification', 'American Heart Association',
 '2024-05-20', '2026-05-20', 'ACLS-2024-007', 8.0),
(7, 'Incident Command System 100', 'Training', 'FEMA',
 '2024-06-15', NULL, 'ICS100-2024-007', 4.0),

-- Henry Harris (volunteer 8)
(8, 'Critical Care Nursing Certification', 'Certification', 'AACN',
 '2024-03-25', '2027-03-25', 'CCRN-2024-008', 20.0),
(8, 'Ventilator Management', 'Training', 'VCU Health',
 '2024-04-10', NULL, 'VM-2024-008', 8.0),

-- Isabel Ingram (volunteer 9)
(9, 'Immunization Administration', 'Certification', 'CDC',
 '2024-07-01', '2027-07-01', 'IA-2024-009', 8.0),
(9, 'Vaccine Storage and Handling', 'Training', 'CDC',
 '2024-08-15', NULL, 'VSH-2024-009', 4.0),

-- Jack Jackson (volunteer 10)
(10, 'Basic Life Support', 'Certification', 'American Heart Association',
 '2024-09-01', '2026-09-01', 'BLS-2024-010', 4.0),
(10, 'Student Clinical Skills', 'Training', 'VCU School of Nursing',
 '2024-10-01', NULL, 'SCS-2024-010', 12.0);

-- Reset sequences
SELECT setval('tenants_id_seq', (SELECT MAX(id) FROM tenants));
SELECT setval('users_id_seq', (SELECT MAX(id) FROM users));
SELECT setval('volunteers_id_seq', (SELECT MAX(id) FROM volunteers));
SELECT setval('events_id_seq', (SELECT MAX(id) FROM events));
SELECT setval('shifts_id_seq', (SELECT MAX(id) FROM shifts));
SELECT setval('event_assignments_id_seq', (SELECT MAX(id) FROM event_assignments));
SELECT setval('training_records_id_seq', (SELECT MAX(id) FROM training_records));
SELECT setval('audit_logs_id_seq', (SELECT MAX(id) FROM audit_logs));

-- Grant permissions
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO vvhs;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vvhs;

-- Display summary
DO $$
BEGIN
    RAISE NOTICE '';
    RAISE NOTICE '=== VVHS Enhanced Database Initialized Successfully ===';
    RAISE NOTICE '';
    RAISE NOTICE 'Created:';
    RAISE NOTICE '  - 4 Tenants';
    RAISE NOTICE '  - 4 Staff Users';
    RAISE NOTICE '  - 12 Volunteers (10 for VDH, 2 for Richmond MRC)';
    RAISE NOTICE '  - 6 Events (all for VDH)';
    RAISE NOTICE '  - 6 Shifts';
    RAISE NOTICE '  - 19 Training Records';
    RAISE NOTICE '  - 14 Event Assignments';
    RAISE NOTICE '';
    RAISE NOTICE 'Login Credentials (password: t3st45#!$6!):';
    RAISE NOTICE '  System Admin: admin@vdh.virginia.gov';
    RAISE NOTICE '  System Admin: mike.wilson@vdh.virginia.gov';
    RAISE NOTICE '  Org Admin (VDH): laura.martinez@vdh.virginia.gov';
    RAISE NOTICE '  Org Admin (Richmond): coordinator@richmond-mrc.org';
    RAISE NOTICE '';
    RAISE NOTICE '========================================================';
END $$;======================================

======================================
File: Dockerfile
Path: ./api
--------------------------------------
# ---------- api/Dockerfile ----------
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    postgresql-client \
	curl \
    && rm -rf /var/lib/apt/lists/*

# Copy and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY ./app /app

# Expose FastAPI default port
EXPOSE 8000

# Start FastAPI using uvicorn
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
======================================

======================================
File: docker-compose.yml
Path: .
--------------------------------------
version: "3.9"

services:
  api:
    build: ./api
    container_name: vvhs-api
    depends_on:
      - db
    env_file:
      - .env
    environment:
      - SECRET_KEY=devsecretkey 
      - DATABASE_URL=postgresql://vvhs:vvhs_password@vvhs-db:5432/vvhs_db
      - CORS_ORIGINS=https://vvhs-saas.sitevision.com
      - ACCESS_TOKEN_EXPIRE_MINUTES=1440  
    ports:
      - "8000:8000"   # Host:Container for FastAPI
    expose:
      - "8000"
    volumes:
      - ./api/app:/app
    restart: unless-stopped
    networks:
      - vvhs-network
      - caddy

  db:
    image: postgres:16
    container_name: vvhs-db
    environment:
      POSTGRES_USER: vvhs
      POSTGRES_PASSWORD: vvhs_password
      POSTGRES_DB: vvhs_db
    ports:
      - "5432:5432"   # Host:Container for Postgres
    expose:
      - "5432"
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./api/db_init:/docker-entrypoint-initdb.d
    restart: unless-stopped
    networks:
      - vvhs-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: vvhs-frontend
    depends_on:
      - api
    expose:
      - "80"
    restart: unless-stopped
    networks:
      - caddy

volumes:
  db_data:

networks:
  vvhs-network:
    name: vvhs-network
    driver: bridge
  caddy:
    name: caddy
    external: true
======================================

